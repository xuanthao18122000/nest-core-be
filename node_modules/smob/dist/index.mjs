function t(t,r,n){return n?[...new Set(t.concat(r))]:t.concat(r)}function r(t,r){return Object.prototype.hasOwnProperty.call(t,r)}function n(t){return!!t&&"object"==typeof t&&!Array.isArray(t)}function e(t,i){if(i<=0)return n(t);if("object"!=typeof t)return!1;const c=i-1,o=Object.keys(t);for(let n=0;n<o.length;n++)if(r(t,o[n])&&e(t[o[n]],c))return!0;return!1}function i(t){try{return JSON.stringify(t),!0}catch(t){return!1}}function c(t){return"__proto__"!==t&&"prototype"!==t&&"constructor"!==t}function o(){return o=Object.assign||function(t){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t[e]=n[e])}return t},o.apply(this,arguments)}function a(t,r){if(r<0)return{};const e=o({},t),i=Object.keys(e);for(let t=0;t<i.length;t++)n(e[i[t]])&&(e[i[t]]=0===r?{}:a(e[i[t]],r-1));return e}function s(t){var r,n;return(t=t||{}).array=null==(r=t.array)||r,t.arrayDistinct=null!=(n=t.arrayDistinct)&&n,t.priority=t.priority||"left",t}function u(e,o,...a){if(!a.length)return o;const s=a.shift();if(n(o)&&n(s)){const a=Object.keys(s);for(let f=0;f<a.length;f++){const y=a[f];if(c(y))if(r(o,y)){if(e.strategy){if(void 0!==e.strategy(o,y,s[y]))continue}if(!i(s[y]))continue;if(n(o[y])&&n(s[y])){u(e,o[y],s[y]);continue}if(e.array&&Array.isArray(o[y])&&Array.isArray(s[y])){switch(e.priority){case"left":Object.assign(o,{[y]:t(o[y],s[y],e.arrayDistinct)});break;case"right":Object.assign(o,{[y]:t(s[y],o[y],e.arrayDistinct)})}continue}"right"===e.priority&&Object.assign(o,{[y]:s[y]})}else Object.assign(o,{[y]:s[y]})}}return u(e,o,...a)}function f(t){const r=s(t);return(t,...n)=>u(r,t,...n)}const y=f();export{u as baseMerger,s as buildOptions,f as createMerger,a as cutObject,r as hasOwnProperty,n as isObject,e as isObjectDeeperThan,c as isSafeKey,i as isSafeObject,y as merge,t as mergeArrays};
//# sourceMappingURL=index.mjs.map
