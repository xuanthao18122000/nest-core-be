"use strict";function t(t,r,e){return e?[...new Set(t.concat(r))]:t.concat(r)}function r(t,r){return Object.prototype.hasOwnProperty.call(t,r)}function e(t){return!!t&&"object"==typeof t&&!Array.isArray(t)}function n(t){try{return JSON.stringify(t),!0}catch(t){return!1}}function i(t){return"__proto__"!==t&&"prototype"!==t&&"constructor"!==t}function o(){return o=Object.assign||function(t){for(var r=1;r<arguments.length;r++){var e=arguments[r];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])}return t},o.apply(this,arguments)}function s(t){var r,e;return(t=t||{}).array=null==(r=t.array)||r,t.arrayDistinct=null!=(e=t.arrayDistinct)&&e,t.priority=t.priority||"left",t}function c(o,s,...a){if(!a.length)return s;const u=a.shift();if(e(s)&&e(u)){const a=Object.keys(u);for(let f=0;f<a.length;f++){const y=a[f];if(i(y))if(r(s,y)){if(o.strategy){if(void 0!==o.strategy(s,y,u[y]))continue}if(!n(u[y]))continue;if(e(s[y])&&e(u[y])){c(o,s[y],u[y]);continue}if(o.array&&Array.isArray(s[y])&&Array.isArray(u[y])){switch(o.priority){case"left":Object.assign(s,{[y]:t(s[y],u[y],o.arrayDistinct)});break;case"right":Object.assign(s,{[y]:t(u[y],s[y],o.arrayDistinct)})}continue}"right"===o.priority&&Object.assign(s,{[y]:u[y]})}else Object.assign(s,{[y]:u[y]})}}return c(o,s,...a)}function a(t){const r=s(t);return(t,...e)=>c(r,t,...e)}const u=a();exports.baseMerger=c,exports.buildOptions=s,exports.createMerger=a,exports.cutObject=function t(r,n){if(n<0)return{};const i=o({},r),s=Object.keys(i);for(let r=0;r<s.length;r++)e(i[s[r]])&&(i[s[r]]=0===n?{}:t(i[s[r]],n-1));return i},exports.hasOwnProperty=r,exports.isObject=e,exports.isObjectDeeperThan=function t(n,i){if(i<=0)return e(n);if("object"!=typeof n)return!1;const o=i-1,s=Object.keys(n);for(let e=0;e<s.length;e++)if(r(n,s[e])&&t(n[s[e]],o))return!0;return!1},exports.isSafeKey=i,exports.isSafeObject=n,exports.merge=u,exports.mergeArrays=t;
//# sourceMappingURL=index.cjs.map
