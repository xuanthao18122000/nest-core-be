{"version":3,"file":"index.cjs","sources":["../src/constants.ts","../src/utils/array.ts","../src/utils/object.ts","../src/utils/mapping.ts","../src/utils/field.ts","../src/utils/relation.ts","../src/parameter/fields/build.ts","../src/parameter/fields/constants.ts","../src/parameter/filters/constants.ts","../src/parameter/sort/type.ts","../src/parameter/utils/parse/allowed-option.ts","../src/parameter/fields/utils/input.ts","../src/parameter/fields/utils/name.ts","../src/parameter/fields/parse.ts","../src/parameter/filters/build.ts","../src/parameter/filters/utils/value.ts","../src/parameter/filters/utils/operator.ts","../src/parameter/filters/parse.ts","../src/parameter/pagination/build.ts","../src/parameter/pagination/parse.ts","../src/parameter/relations/build.ts","../src/parameter/relations/utils/parents.ts","../src/parameter/relations/parse.ts","../src/parameter/relations/utils/path.ts","../src/parameter/sort/build.ts","../src/parameter/sort/utils.ts","../src/parameter/sort/parse.ts","../src/parse/parameter/module.ts","../src/parse/parameter/utils.ts","../src/parameter/fields/utils/domain.ts","../src/build/module.ts","../src/utils/url.ts","../src/parse/module.ts"],"sourcesContent":["/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\n// -----------------------------------------------------------\n\nexport enum Parameter {\n    FILTERS = 'filters',\n    FIELDS = 'fields',\n    PAGINATION = 'pagination',\n    RELATIONS = 'relations',\n    SORT = 'sort',\n}\n\n// -----------------------------------------------------------\n\nexport enum URLParameter {\n    FILTERS = 'filter',\n    FIELDS = 'fields',\n    PAGINATION = 'page',\n    RELATIONS = 'include',\n    SORT = 'sort',\n}\n\n// -----------------------------------------------------------\n\nexport const DEFAULT_ID = '__DEFAULT__';\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { DEFAULT_ID } from '../constants';\n\nexport function buildKeyPath(key: string, prefix?: string) {\n    if (typeof prefix === 'string') {\n        return `${prefix}.${key}`;\n    }\n\n    return key;\n}\n\ntype Options = {\n    transformer?: (\n        input: unknown,\n        output: string[],\n        prefix?: string\n    ) => boolean | undefined\n};\n\nexport function flattenToKeyPathArray(\n    input: unknown,\n    options?: Options,\n    prefix?: string,\n): string[] {\n    options = options || {};\n\n    const output: string[] = [];\n\n    if (options.transformer) {\n        const result = options.transformer(input, output, prefix);\n        if (typeof result !== 'undefined' && !!result) {\n            return output;\n        }\n    }\n\n    if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (options.transformer) {\n                const result = options.transformer(input[i], output, prefix);\n                if (typeof result !== 'undefined' && !!result) {\n                    return output;\n                }\n            }\n\n            if (Array.isArray(input[i])) {\n                for (let j = 0; j < input[i].length; j++) {\n                    const key = buildKeyPath(input[i][j], prefix);\n                    output.push(key);\n                }\n\n                continue;\n            }\n\n            if (typeof input[i] === 'string') {\n                output.push(buildKeyPath(input[i], prefix));\n\n                continue;\n            }\n\n            if (typeof input[i] === 'object') {\n                const keys = Object.keys(input[i]);\n                for (let j = 0; j < keys.length; j++) {\n                    const value = buildKeyPath(keys[j] as string, prefix);\n                    const data = flattenToKeyPathArray(input[i][keys[j]], options, value);\n                    if (data.length === 0) {\n                        output.push(value);\n                    } else {\n                        output.push(...data);\n                    }\n                }\n            }\n        }\n\n        return output;\n    }\n\n    if (\n        typeof input === 'object' &&\n        input !== null\n    ) {\n        const keys = Object.keys(input);\n        for (let i = 0; i < keys.length; i++) {\n            const value = buildKeyPath(keys[i], prefix);\n            const data = flattenToKeyPathArray((input as Record<string, any>)[keys[i]], options, value);\n            if (data.length === 0) {\n                output.push(value);\n            } else {\n                output.push(...data);\n            }\n        }\n\n        return output;\n    }\n\n    if (\n        typeof input === 'string'\n    ) {\n        const value = buildKeyPath(input, prefix);\n        output.push(value);\n\n        return output;\n    }\n\n    return output;\n}\n\nexport function groupArrayByKeyPath(input: string[]): Record<string, string[]> {\n    const pathItems: Record<string, string[]> = {};\n\n    for (let i = 0; i < input.length; i++) {\n        const parts = input[i].split('.');\n\n        let key: string;\n        let name: string;\n        if (parts.length === 1) {\n            key = DEFAULT_ID;\n            name = input[i];\n        } else {\n            name = parts.pop() as string;\n            key = parts.join('.');\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(pathItems, key)) {\n            pathItems[key] = [];\n        }\n\n        pathItems[key].push(name);\n    }\n\n    return pathItems;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function hasOwnProperty<\n    X extends Record<string, any>,\n    Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\ntype Options = {\n    transformer?: (\n        input: unknown,\n        output: Record<string, any>,\n        key: string\n    ) => boolean | undefined\n};\n\nexport function flattenNestedObject(\n    data: Record<string, any>,\n    options?: Options,\n    prefixParts?: string[],\n): Record<string, any> {\n    options = options || {};\n    prefixParts = prefixParts || [];\n\n    let output: Record<string, string> = {};\n\n    if (options.transformer) {\n        const result = options.transformer(data, output, prefixParts.join('.'));\n        if (typeof result !== 'undefined' && !!result) {\n            return output;\n        }\n    }\n\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (options.transformer) {\n            const result = options.transformer(data[key], output, [...prefixParts, key].join('.'));\n            if (typeof result !== 'undefined' && !!result) {\n                continue;\n            }\n        }\n\n        if (\n            typeof data[key] === 'object' &&\n            data[key]\n        ) {\n            output = { ...output, ...flattenNestedObject(data[key], options, [...prefixParts, key]) };\n\n            continue;\n        }\n\n        const destinationKey = [...prefixParts, key].join('.');\n\n        if (\n            typeof data[key] === 'boolean' ||\n            typeof data[key] === 'string' ||\n            typeof data[key] === 'number' ||\n            typeof data[key] === 'undefined' ||\n            data[key] === null ||\n            Array.isArray(data[key])\n        ) {\n            output[destinationKey] = data[key];\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { hasOwnProperty } from './object';\n\nexport function applyMapping(\n    name: string,\n    map?: Record<string, string>,\n    onlyKey?: boolean,\n) {\n    if (typeof map === 'undefined') {\n        return name;\n    }\n\n    let parts = name.split('.');\n\n    const output = [];\n    let run = true;\n    while (run) {\n        const value = parts.shift();\n        if (typeof value === 'undefined') {\n            run = false;\n            break;\n        }\n\n        if (hasOwnProperty(map, value)) {\n            output.push(map[value]);\n        } else {\n            let found = false;\n\n            const rest : string[] = [];\n            const copy = [...parts];\n            while (copy.length > 0) {\n                const key = [value, ...copy].join('.');\n                if (hasOwnProperty(map, key)) {\n                    output.push(map[key]);\n                    found = true;\n                    break;\n                } else {\n                    const last = copy.pop();\n                    if (last) {\n                        rest.unshift(last);\n                    }\n                }\n            }\n\n            if (found) {\n                parts = rest;\n            } else {\n                output.push(value);\n            }\n        }\n    }\n\n    if (onlyKey) {\n        return output.pop() || name;\n    }\n\n    if (output.length === 0) {\n        return name;\n    }\n\n    return output.join('.');\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FieldDetails } from './type';\n\nexport function getFieldDetails(field: string) : FieldDetails {\n    const parts : string[] = field.split('.');\n\n    return {\n        name: parts.pop() as string,\n        path: parts.length > 0 ? parts.join('.') : undefined,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { RelationsParseOutput } from '../parameter';\nimport { getFieldDetails } from './field';\nimport { FieldDetails } from './type';\n\nexport function isFieldNonRelational(field: string | FieldDetails) {\n    const details = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    return typeof details.path === 'undefined';\n}\n\nexport function isFieldPathAllowedByRelations(\n    field: string | Pick<FieldDetails, 'path'>,\n    includes?: RelationsParseOutput,\n) : boolean {\n    if (typeof includes === 'undefined') {\n        return true;\n    }\n\n    const details : Pick<FieldDetails, 'path'> = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    if (\n        typeof details.path === 'undefined'\n    ) {\n        return true;\n    }\n\n    return includes.some(\n        (include) => include.key === details.path,\n    );\n}\n\nexport function buildFieldWithPath(\n    field: string | FieldDetails,\n    path?: string,\n) : string {\n    const details = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    return details.path || path ?\n        `${details.path || path}.${details.name}` :\n        details.name;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { createMerger } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport { FieldsBuildInput } from './type';\nimport { flattenToKeyPathArray, groupArrayByKeyPath } from '../../utils';\n\nexport function buildQueryFields<T extends ObjectLiteral = ObjectLiteral>(\n    input?: FieldsBuildInput<T>,\n) : Record<string, string[]> | string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    const data = groupArrayByKeyPath(flattenToKeyPathArray(input));\n\n    const keys = Object.keys(data);\n    if (keys.length === 1) {\n        return data[keys[0]];\n    }\n\n    return data;\n}\n\nexport function mergeQueryFields(\n    target: Record<string, string[]> | string[],\n    source: Record<string, string[]> | string[],\n): Record<string, string[]> | string[] {\n    if (Array.isArray(target)) {\n        target = groupArrayByKeyPath(target);\n    }\n\n    if (Array.isArray(source)) {\n        source = groupArrayByKeyPath(source);\n    }\n\n    const merge = createMerger({\n        array: true,\n        arrayDistinct: true,\n    });\n\n    const data = merge({}, target, source);\n\n    const keys = Object.keys(data);\n    if (keys.length === 1) {\n        return data[keys[0]];\n    }\n\n    return data;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum FieldOperator {\n    INCLUDE = '+',\n    EXCLUDE = '-',\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum FilterComparisonOperator {\n    EQUAL = '$eq',\n    NOT_EQUAL = '$ne',\n    LIKE = '$l',\n    NOT_LIKE = '$nl',\n    LESS_THAN_EQUAL = '$lte',\n    LESS_THAN = '$lt',\n    GREATER_THAN_EQUAL = '$gte',\n    GREATER_THAN = '$gt',\n    IN = '$in',\n    NOT_IN = '$nin',\n}\n\nexport enum FilterInputOperatorValue {\n    NEGATION = '!',\n    LIKE = '~',\n    LESS_THAN_EQUAL = '<=',\n    LESS_THAN = '<',\n    MORE_THAN_EQUAL = '>=',\n    MORE_THAN = '>',\n    IN = ',',\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport {\n    Flatten, KeyWithOptionalPrefix, NestedKeys, OnlyObject, SimpleKeys,\n} from '../../type';\nimport { RelationsParseOutput } from '../relations';\nimport {\n    ParseAllowedOption,\n} from '../type';\n\nexport enum SortDirection {\n    ASC = 'ASC',\n    DESC = 'DESC',\n}\n\n// -----------------------------------------------------------\n// Build\n// -----------------------------------------------------------\n\ntype SortWithOperator<T extends string> = KeyWithOptionalPrefix<T, '-'>;\n\nexport type SortBuildInput<T extends Record<string, any>> =\n    {\n        [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n            SortBuildInput<Flatten<T[K]>> :\n            `${SortDirection}`\n    }\n    |\n    (\n        SortWithOperator<SimpleKeys<T>>[] |\n        {\n            [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n                SortBuildInput<Flatten<T[K]>> :\n                `${SortDirection}`\n        }\n    )[]\n    |\n    SortWithOperator<NestedKeys<T>>[] |\n    SortWithOperator<NestedKeys<T>>;\n\n// -----------------------------------------------------------\n// Parse\n// -----------------------------------------------------------\n\nexport type SortParseDefaultOption<T extends Record<string, any>> = {\n    [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n        SortParseDefaultOption<Flatten<T[K]>> :\n        `${SortDirection}`\n} | {\n    [K in NestedKeys<T>]?: `${SortDirection}`\n};\n\nexport type SortParseOptions<\n    T extends Record<string, any> = Record<string, any>,\n    > = {\n        allowed?: ParseAllowedOption<T>,\n        mapping?: Record<string, string>,\n        default?: SortParseDefaultOption<T>,\n        defaultPath?: string,\n        relations?: RelationsParseOutput,\n    };\nexport type SortParseOutputElement = {\n    key: string,\n    value: `${SortDirection}`,\n    path?: string\n};\nexport type SortParseOutput = SortParseOutputElement[];\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { NestedKeys, NestedResourceKeys, ObjectLiteral } from '../../../type';\nimport { flattenToKeyPathArray } from '../../../utils';\nimport { ParseAllowedOption } from '../../type';\n\nexport function flattenParseAllowedOption<T extends ObjectLiteral>(\n    input?: ParseAllowedOption<T>,\n) : string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    return flattenToKeyPathArray(input);\n}\n\nexport function isPathCoveredByParseAllowedOption<T extends ObjectLiteral>(\n    input: ParseAllowedOption<T> |\n    NestedKeys<T>[] |\n    NestedResourceKeys<T>[],\n    path: string | string[],\n) : boolean {\n    const paths = Array.isArray(path) ? path : [path];\n\n    const items = flattenToKeyPathArray(input);\n    for (let i = 0; i < items.length; i++) {\n        if (paths.indexOf(items[i]) !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FieldsInputTransformed } from '../type';\nimport { FieldOperator } from '../constants';\n\nexport function removeFieldInputOperator(field: string) {\n    const firstCharacter = field.substring(0, 1);\n\n    return firstCharacter === FieldOperator.INCLUDE ||\n        firstCharacter === FieldOperator.EXCLUDE ?\n        field.substring(1) :\n        field;\n}\n\nexport function transformFieldsInput(\n    fields: string[],\n): FieldsInputTransformed {\n    const output: FieldsInputTransformed = {\n        default: [],\n        included: [],\n        excluded: [],\n    };\n\n    for (let i = 0; i < fields.length; i++) {\n        let operator: FieldOperator | undefined;\n\n        const character = fields[i].substring(0, 1);\n\n        if (character === FieldOperator.INCLUDE) {\n            operator = FieldOperator.INCLUDE;\n        } else if (character === FieldOperator.EXCLUDE) {\n            operator = FieldOperator.EXCLUDE;\n        }\n\n        if (operator) {\n            fields[i] = fields[i].substring(1);\n\n            switch (operator) {\n                case FieldOperator.INCLUDE: {\n                    output.included.push(fields[i]);\n                    break;\n                }\n                case FieldOperator.EXCLUDE: {\n                    output.excluded.push(fields[i]);\n                    break;\n                }\n            }\n        } else {\n            output.default.push(fields[i]);\n        }\n    }\n\n    return output;\n}\n\nexport function parseFieldsInput(input: unknown): string[] {\n    let output: string[] = [];\n\n    if (typeof input === 'string') {\n        output = input.split(',');\n    } else if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (typeof input[i] === 'string') {\n                output.push(input[i]);\n            }\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isValidFieldName(input: string) : boolean {\n    return /^[a-zA-Z_][a-zA-Z0-9_]*$/gu.test(input);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject, merge } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport {\n    applyMapping, buildFieldWithPath, groupArrayByKeyPath, hasOwnProperty, isFieldPathAllowedByRelations,\n} from '../../utils';\nimport { flattenParseAllowedOption } from '../utils';\nimport {\n    FieldsInputTransformed, FieldsParseOptions, FieldsParseOutput,\n} from './type';\nimport {\n    isValidFieldName,\n    parseFieldsInput, removeFieldInputOperator,\n    transformFieldsInput,\n} from './utils';\nimport { DEFAULT_ID } from '../../constants';\n\n// --------------------------------------------------\n\nfunction buildReverseRecord(\n    record: Record<string, string>,\n) : Record<string, string> {\n    const keys = Object.keys(record);\n    const output : Record<string, string> = {};\n\n    for (let i = 0; i < keys.length; i++) {\n        output[record[keys[i]]] = keys[i];\n    }\n\n    return output;\n}\n\nexport function parseQueryFields<T extends ObjectLiteral = ObjectLiteral>(\n    input: unknown,\n    options?: FieldsParseOptions<T>,\n) : FieldsParseOutput {\n    options = options || {};\n\n    const defaultDomainFields = groupArrayByKeyPath(\n        flattenParseAllowedOption(options.default),\n    );\n\n    const allowedDomainFields = groupArrayByKeyPath(\n        flattenParseAllowedOption(options.allowed),\n    );\n\n    const domainFields = merge(\n        {},\n        defaultDomainFields,\n        allowedDomainFields,\n    );\n\n    let keys : string[] = Object.keys(domainFields);\n\n    // If it is an empty array nothing is allowed\n    if (\n        (\n            typeof options.default !== 'undefined' ||\n            typeof options.allowed !== 'undefined'\n        ) &&\n        keys.length === 0\n    ) {\n        return [];\n    }\n\n    let data : Record<string, any> = {\n        [DEFAULT_ID]: [],\n    };\n\n    if (isObject(input)) {\n        data = input;\n    } else if (typeof input === 'string') {\n        data = { [DEFAULT_ID]: input };\n    } else if (Array.isArray(input)) {\n        data = { [DEFAULT_ID]: input };\n    }\n\n    options.mapping = options.mapping || {};\n    const reverseMapping = buildReverseRecord(options.mapping);\n\n    if (keys.length === 0) {\n        keys = Object.keys(data);\n    }\n\n    const output : FieldsParseOutput = [];\n\n    for (let i = 0; i < keys.length; i++) {\n        const path = keys[i];\n\n        if (\n            !isFieldPathAllowedByRelations({ path }, options.relations) &&\n            path !== DEFAULT_ID\n        ) {\n            continue;\n        }\n\n        let fields : string[] = [];\n\n        if (hasOwnProperty(data, path)) {\n            fields = parseFieldsInput(data[path]);\n        } else if (\n            hasOwnProperty(reverseMapping, path) &&\n            hasOwnProperty(data, reverseMapping[path])\n        ) {\n            fields = parseFieldsInput(data[reverseMapping[path]]);\n        }\n\n        let transformed : FieldsInputTransformed = {\n            default: [],\n            included: [],\n            excluded: [],\n        };\n\n        if (fields.length > 0) {\n            for (let j = 0; j < fields.length; j++) {\n                fields[j] = applyMapping(\n                    buildFieldWithPath({ name: fields[j], path }),\n                    options.mapping,\n                    true,\n                );\n            }\n\n            if (hasOwnProperty(domainFields, path)) {\n                fields = fields.filter((field) => domainFields[path].indexOf(\n                    removeFieldInputOperator(field),\n                ) !== -1);\n            } else {\n                fields = fields.filter((field) => isValidFieldName(removeFieldInputOperator(field)));\n            }\n\n            transformed = transformFieldsInput(\n                fields,\n            );\n        }\n\n        if (\n            transformed.default.length === 0 &&\n            hasOwnProperty(defaultDomainFields, path)\n        ) {\n            transformed.default = defaultDomainFields[path];\n        }\n\n        if (\n            transformed.included.length === 0 &&\n            transformed.default.length === 0 &&\n            hasOwnProperty(allowedDomainFields, path)\n        ) {\n            transformed.default = allowedDomainFields[path];\n        }\n\n        transformed.default = Array.from(new Set([\n            ...transformed.default,\n            ...transformed.included,\n        ]));\n\n        for (let j = 0; j < transformed.excluded.length; j++) {\n            const index = transformed.default.indexOf(transformed.excluded[j]);\n            if (index !== -1) {\n                transformed.default.splice(index, 1);\n            }\n        }\n\n        if (transformed.default.length > 0) {\n            for (let j = 0; j < transformed.default.length; j++) {\n                let destPath : string | undefined;\n                if (path !== DEFAULT_ID) {\n                    destPath = path;\n                } else if (options.defaultPath) {\n                    destPath = options.defaultPath;\n                }\n\n                output.push({\n                    key: transformed.default[j],\n                    ...(destPath ? { path: destPath } : {}),\n                });\n            }\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { merge } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport { FiltersBuildInput } from './type';\nimport { flattenNestedObject } from '../../utils';\n\nexport function buildQueryFilters<T extends ObjectLiteral = ObjectLiteral>(\n    data?: FiltersBuildInput<T>,\n) : Record<string, any> {\n    if (typeof data === 'undefined') {\n        return {};\n    }\n\n    return flattenNestedObject(data, {\n        transformer: (input, output, key) => {\n            if (typeof input === 'undefined') {\n                output[key] = null;\n\n                return true;\n            }\n\n            if (Array.isArray(input)) {\n                // preserve null values\n                const data : string[] = [];\n                for (let i = 0; i < input.length; i++) {\n                    if (input[i] === null) {\n                        input[i] = 'null';\n                    }\n\n                    if (typeof input[i] === 'number') {\n                        input[i] = `${input[i]}`;\n                    }\n\n                    if (typeof input[i] === 'string') {\n                        data.push(input[i]);\n                    }\n                }\n\n                output[key] = data.join(',');\n\n                return true;\n            }\n\n            return undefined;\n        },\n    });\n}\n\nexport function mergeQueryFilters(\n    target?: Record<string, any>,\n    source?: Record<string, any>,\n) : Record<string, any> {\n    return merge({}, target || {}, source || {});\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FilterValueSimple } from '../type';\n\nexport function transformFilterValue(input: FilterValueSimple) : FilterValueSimple {\n    if (typeof input === 'string') {\n        input = input.trim();\n        const lower = input.toLowerCase();\n\n        if (lower === 'true') {\n            return true;\n        }\n\n        if (lower === 'false') {\n            return false;\n        }\n\n        if (lower === 'null') {\n            return null;\n        }\n\n        if (input.length === 0) {\n            return input;\n        }\n\n        const num = Number(input);\n        if (!Number.isNaN(num)) {\n            return num;\n        }\n\n        const parts = input.split(',');\n        if (parts.length > 1) {\n            return transformFilterValue(parts);\n        }\n    }\n\n    if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            input[i] = transformFilterValue(input[i]) as string | number;\n        }\n\n        return (input as unknown[])\n            .filter((n) => n === 0 || n === null || !!n) as FilterValueSimple;\n    }\n\n    if (typeof input === 'undefined' || input === null) {\n        return null;\n    }\n\n    return input;\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FilterComparisonOperator, FilterInputOperatorValue } from '../constants';\nimport { FilterValueSimple } from '../type';\n\nfunction matchOperator(key: string, value: FilterValueSimple, position: 'start' | 'end' | 'global') : FilterValueSimple | undefined {\n    if (typeof value === 'string') {\n        switch (position) {\n            case 'start': {\n                if (value.substring(0, key.length) === key) {\n                    return value.substring(key.length);\n                }\n                break;\n            }\n            case 'end': {\n                if (value.substring(0 - key.length) === key) {\n                    return value.substring(0, value.length - key.length - 1);\n                }\n                break;\n            }\n        }\n\n        return undefined;\n    }\n\n    if (Array.isArray(value)) {\n        let match = false;\n        for (let i = 0; i < value.length; i++) {\n            const output = matchOperator(key, value[i], position);\n            if (typeof output !== 'undefined') {\n                match = true;\n                value[i] = output as string | number;\n            }\n        }\n\n        if (match) {\n            return value;\n        }\n    }\n\n    return undefined;\n}\n\nexport function parseFilterValue(input: FilterValueSimple) : {\n    operator: `${FilterComparisonOperator}`,\n    value: FilterValueSimple\n} {\n    if (\n        typeof input === 'string' &&\n        input.includes(FilterInputOperatorValue.IN)\n    ) {\n        input = input.split(FilterInputOperatorValue.IN);\n    }\n\n    let negation = false;\n\n    let value = matchOperator(FilterInputOperatorValue.NEGATION, input, 'start');\n    if (typeof value !== 'undefined') {\n        negation = true;\n        input = value;\n    }\n\n    if (Array.isArray(input)) {\n        return {\n            value: input,\n            operator: negation ?\n                FilterComparisonOperator.NOT_IN :\n                FilterComparisonOperator.IN,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LIKE, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: negation ?\n                FilterComparisonOperator.NOT_LIKE :\n                FilterComparisonOperator.LIKE,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LESS_THAN_EQUAL, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.LESS_THAN_EQUAL,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LESS_THAN, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.LESS_THAN,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.MORE_THAN_EQUAL, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.GREATER_THAN_EQUAL,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.MORE_THAN, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.GREATER_THAN,\n        };\n    }\n\n    return {\n        value: input,\n        operator: negation ?\n            FilterComparisonOperator.NOT_EQUAL :\n            FilterComparisonOperator.EQUAL,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { NestedKeys, ObjectLiteral } from '../../type';\nimport {\n    FieldDetails,\n    applyMapping,\n    buildFieldWithPath,\n    flattenNestedObject,\n    getFieldDetails,\n    hasOwnProperty, isFieldNonRelational, isFieldPathAllowedByRelations,\n} from '../../utils';\nimport { isValidFieldName } from '../fields';\nimport { ParseAllowedOption } from '../type';\nimport { flattenParseAllowedOption, isPathCoveredByParseAllowedOption } from '../utils';\nimport { FilterComparisonOperator } from './constants';\nimport { FiltersParseOptions, FiltersParseOutput, FiltersParseOutputElement } from './type';\nimport { parseFilterValue, transformFilterValue } from './utils';\n\n// --------------------------------------------------\n\nfunction transformFiltersParseOutputElement(element: FiltersParseOutputElement) : FiltersParseOutputElement {\n    if (\n        hasOwnProperty(element, 'path') &&\n        (typeof element.path === 'undefined' || element.path === null)\n    ) {\n        delete element.path;\n    }\n\n    if (element.operator) {\n        return element;\n    }\n\n    if (typeof element.value === 'string') {\n        element = {\n            ...element,\n            ...parseFilterValue(element.value),\n        };\n    } else {\n        element.operator = FilterComparisonOperator.EQUAL;\n    }\n\n    element.value = transformFilterValue(element.value);\n\n    return element;\n}\n\nfunction buildDefaultFiltersParseOutput<T extends ObjectLiteral = ObjectLiteral>(\n    options: FiltersParseOptions<T>,\n    input: Record<string, FiltersParseOutputElement> = {},\n) : FiltersParseOutput {\n    const inputKeys = Object.keys(input || {});\n\n    if (\n        !options.defaultByElement &&\n        inputKeys.length > 0\n    ) {\n        return Object.values(input);\n    }\n\n    if (options.default) {\n        const flatten = flattenNestedObject(options.default);\n        const keys = Object.keys(flatten);\n\n        const output : FiltersParseOutput = [];\n\n        for (let i = 0; i < keys.length; i++) {\n            const fieldDetails = getFieldDetails(keys[i]);\n\n            if (\n                options.defaultByElement &&\n                inputKeys.length > 0\n            ) {\n                const fieldWithAlias = buildFieldWithPath(fieldDetails);\n                if (hasOwnProperty(input, fieldWithAlias)) {\n                    continue;\n                }\n            }\n\n            if (options.defaultByElement || inputKeys.length === 0) {\n                let path : string | undefined;\n                if (fieldDetails.path) {\n                    path = fieldDetails.path;\n                } else if (options.defaultPath) {\n                    path = options.defaultPath;\n                }\n\n                output.push(transformFiltersParseOutputElement({\n                    ...(path ? { path } : {}),\n                    key: fieldDetails.name,\n                    value: flatten[keys[i]],\n                }));\n            }\n        }\n\n        return input ? [...Object.values(input), ...output] : output;\n    }\n\n    return input ? Object.values(input) : [];\n}\n\nexport function parseQueryFilters<T extends ObjectLiteral = ObjectLiteral>(\n    data: unknown,\n    options?: FiltersParseOptions<T>,\n) : FiltersParseOutput {\n    options = options || {};\n    options.mapping = options.mapping || {};\n    options.relations = options.relations || [];\n\n    // If it is an empty array nothing is allowed\n    if (typeof options.allowed !== 'undefined') {\n        options.allowed = flattenParseAllowedOption(options.allowed) as ParseAllowedOption<T>;\n        if (options.allowed.length === 0) {\n            return buildDefaultFiltersParseOutput(options);\n        }\n    }\n\n    /* istanbul ignore next */\n    if (typeof data !== 'object' || data === null) {\n        return buildDefaultFiltersParseOutput(options);\n    }\n\n    const { length } = Object.keys(data);\n    if (length === 0) {\n        return buildDefaultFiltersParseOutput(options);\n    }\n\n    if (\n        (typeof options.allowed === 'undefined' || options.allowed.length === 0) &&\n        options.default\n    ) {\n        const flatten = flattenNestedObject(options.default);\n        options.allowed = Object.keys(flatten) as ParseAllowedOption<T>;\n    }\n\n    const items : Record<string, FiltersParseOutputElement> = {};\n\n    // transform to appreciate data format & validate input\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        /* istanbul ignore next */\n        if (!hasOwnProperty(data, keys[i])) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n\n        const value : unknown = data[keys[i]];\n\n        if (\n            typeof value !== 'string' &&\n            typeof value !== 'number' &&\n            typeof value !== 'boolean' &&\n            typeof value !== 'undefined' &&\n            value !== null &&\n            !Array.isArray(value)\n        ) {\n            continue;\n        }\n\n        keys[i] = applyMapping(keys[i], options.mapping);\n\n        const fieldDetails : FieldDetails = getFieldDetails(keys[i]);\n\n        if (\n            typeof options.allowed === 'undefined' &&\n            !isValidFieldName(fieldDetails.name)\n        ) {\n            continue;\n        }\n\n        if (\n            !isFieldPathAllowedByRelations(fieldDetails, options.relations) &&\n            !isFieldNonRelational(fieldDetails)\n        ) {\n            continue;\n        }\n\n        const fullKey : string = buildFieldWithPath(fieldDetails);\n\n        if (\n            options.allowed &&\n            !isPathCoveredByParseAllowedOption(options.allowed, [keys[i], fullKey])\n        ) {\n            continue;\n        }\n\n        const filter = transformFiltersParseOutputElement({\n            key: fieldDetails.name,\n            value: value as string | boolean | number,\n        });\n\n        if (options.validate) {\n            if (Array.isArray(filter.value)) {\n                const output : (string | number)[] = [];\n                for (let j = 0; j < filter.value.length; j++) {\n                    if (options.validate(filter.key as NestedKeys<T>, filter.value[j])) {\n                        output.push(filter.value[j]);\n                    }\n                }\n\n                filter.value = output as string[] | number[];\n                if (filter.value.length === 0) {\n                    continue;\n                }\n            } else if (!options.validate(filter.key as NestedKeys<T>, filter.value)) {\n                continue;\n            }\n        }\n\n        if (\n            typeof filter.value === 'string' &&\n            filter.value.length === 0\n        ) {\n            continue;\n        }\n\n        if (\n            Array.isArray(filter.value) &&\n            filter.value.length === 0\n        ) {\n            continue;\n        }\n\n        if (fieldDetails.path || options.defaultPath) {\n            filter.path = fieldDetails.path || options.defaultPath;\n        }\n\n        items[fullKey] = filter;\n    }\n\n    return buildDefaultFiltersParseOutput(options, items);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { merge } from 'smob';\nimport { PaginationBuildInput } from './type';\n\nexport function mergeQueryPagination(\n    target?: PaginationBuildInput,\n    source?: PaginationBuildInput,\n) : PaginationBuildInput {\n    return merge({}, target || {}, source || {});\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport { PaginationParseOptions, PaginationParseOutput } from './type';\n\n// --------------------------------------------------\n\nfunction finalizePagination(\n    data: PaginationParseOutput,\n    options: PaginationParseOptions,\n) : PaginationParseOutput {\n    if (typeof options.maxLimit !== 'undefined') {\n        if (\n            typeof data.limit === 'undefined' ||\n            data.limit > options.maxLimit\n        ) {\n            data.limit = options.maxLimit;\n        }\n    }\n\n    if (\n        typeof data.limit !== 'undefined' &&\n        typeof data.offset === 'undefined'\n    ) {\n        data.offset = 0;\n    }\n\n    return data;\n}\n\n/**\n * Transform pagination data to an appreciate data format.\n *\n * @param data\n * @param options\n */\nexport function parseQueryPagination(\n    data: unknown,\n    options?: PaginationParseOptions,\n) : PaginationParseOutput {\n    options = options || {};\n\n    const pagination : PaginationParseOutput = {};\n\n    if (!isObject(data)) {\n        return finalizePagination(pagination, options);\n    }\n\n    let { limit, offset } = data as Record<string, any>;\n\n    if (typeof limit !== 'undefined') {\n        limit = parseInt(limit, 10);\n\n        if (!Number.isNaN(limit) && limit > 0) {\n            pagination.limit = limit;\n        }\n    }\n\n    if (typeof offset !== 'undefined') {\n        offset = parseInt(offset, 10);\n\n        if (!Number.isNaN(offset) && offset >= 0) {\n            pagination.offset = offset;\n        }\n    }\n\n    return finalizePagination(pagination, options);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { mergeArrays } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport { RelationsBuildInput } from './type';\nimport { flattenToKeyPathArray } from '../../utils';\n\nexport function buildQueryRelations<T extends ObjectLiteral = ObjectLiteral>(\n    input?: RelationsBuildInput<T>,\n) : string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    return flattenToKeyPathArray(input);\n}\n\nexport function mergeQueryRelations(\n    target?: string[],\n    source?: string[],\n) : string[] {\n    return mergeArrays(target || [], source || [], true);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function includeParents(\n    data: string[],\n) : string[] {\n    for (let i = 0; i < data.length; i++) {\n        const parts: string[] = data[i].split('.');\n\n        while (parts.length > 0) {\n            parts.pop();\n\n            if (parts.length > 0) {\n                const value = parts.join('.');\n                if (data.indexOf(value) === -1) {\n                    data.unshift(value);\n                }\n            }\n        }\n    }\n\n    return data;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ObjectLiteral } from '../../type';\nimport { applyMapping, hasOwnProperty } from '../../utils';\nimport { isPathCoveredByParseAllowedOption } from '../utils';\n\nimport { RelationsParseOptions, RelationsParseOutput } from './type';\nimport { includeParents, isValidRelationPath } from './utils';\n\n// --------------------------------------------------\n\nexport function parseQueryRelations<T extends ObjectLiteral = ObjectLiteral>(\n    input: unknown,\n    options: RelationsParseOptions<T> = {},\n): RelationsParseOutput {\n    options = options || {};\n\n    // If it is an empty array nothing is allowed\n    if (\n        Array.isArray(options.allowed) &&\n        options.allowed.length === 0\n    ) {\n        return [];\n    }\n\n    options.mapping = options.mapping || {};\n    options.pathMapping = options.pathMapping || {};\n    if (typeof options.includeParents === 'undefined') {\n        options.includeParents = true;\n    }\n\n    let items: string[] = [];\n\n    if (typeof input === 'string') {\n        items = input.split(',');\n    } else if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (typeof input[i] === 'string') {\n                items.push(input[i]);\n            }\n        }\n    }\n\n    if (items.length === 0) {\n        return [];\n    }\n\n    const mappingKeys = Object.keys(options.mapping);\n    if (mappingKeys.length > 0) {\n        for (let i = 0; i < items.length; i++) {\n            items[i] = applyMapping(items[i], options.mapping);\n        }\n    }\n\n    if (options.allowed) {\n        items = items.filter((item) => isPathCoveredByParseAllowedOption(options.allowed as string[], item));\n    } else {\n        items = items.filter((item) => isValidRelationPath(item));\n    }\n\n    if (options.includeParents) {\n        if (Array.isArray(options.includeParents)) {\n            const parentIncludes = items.filter(\n                (item) => item.includes('.') &&\n                    (options.includeParents as string[]).filter((parent) => item.startsWith(parent)).length > 0,\n            );\n            items.unshift(...includeParents(parentIncludes));\n        } else {\n            items = includeParents(items);\n        }\n    }\n\n    items = Array.from(new Set(items));\n\n    return items\n        .map((key) => {\n            const parts = key.split('.');\n\n            let value : string;\n            if (\n                options.pathMapping &&\n                hasOwnProperty(options.pathMapping, key)\n            ) {\n                value = options.pathMapping[key];\n            } else {\n                value = parts.pop() as string;\n            }\n\n            return {\n                key,\n                value,\n            };\n        });\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isValidRelationPath(input: string) : boolean {\n    return /^[a-zA-Z0-9_-]+([.]*[a-zA-Z0-9_-])*$/gu.test(input);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { mergeArrays } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport { SortBuildInput, SortDirection } from './type';\nimport { flattenToKeyPathArray } from '../../utils';\n\nexport function buildQuerySort<T extends ObjectLiteral = ObjectLiteral>(\n    data?: SortBuildInput<T>,\n) {\n    if (typeof data === 'undefined') {\n        return [];\n    }\n\n    if (typeof data === 'string') {\n        return [data];\n    }\n\n    return flattenToKeyPathArray(data, {\n        transformer: ((input, output, path) => {\n            if (\n                typeof input === 'string' &&\n                path &&\n                (\n                    input === SortDirection.ASC ||\n                    input === SortDirection.DESC\n                )\n            ) {\n                if (input === SortDirection.DESC) {\n                    output.push(`-${path}`);\n                } else {\n                    output.push(path);\n                }\n\n                return true;\n            }\n\n            return undefined;\n        }),\n    });\n}\n\nexport function mergeQuerySort(\n    target?: string[],\n    source?: string[],\n) {\n    return mergeArrays(target || [], source || [], true);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { SortDirection } from './type';\n\nexport function parseSortValue(value: string) : {value: string, direction: `${SortDirection}`} {\n    let direction: SortDirection = SortDirection.ASC;\n    if (value.substring(0, 1) === '-') {\n        direction = SortDirection.DESC;\n        value = value.substring(1);\n    }\n\n    return {\n        direction,\n        value,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport {\n    applyMapping,\n    buildFieldWithPath, buildKeyPath, flattenNestedObject,\n    getFieldDetails,\n    hasOwnProperty, isFieldNonRelational,\n    isFieldPathAllowedByRelations,\n} from '../../utils';\nimport { isValidFieldName } from '../fields';\nimport { ParseAllowedOption } from '../type';\nimport { flattenParseAllowedOption, isPathCoveredByParseAllowedOption } from '../utils';\n\nimport {\n    SortParseOptions,\n    SortParseOutput,\n    SortParseOutputElement,\n} from './type';\nimport { parseSortValue } from './utils';\n\n// --------------------------------------------------\n\nfunction isMultiDimensionalArray(arr: unknown) : arr is unknown[][] {\n    if (!Array.isArray(arr)) {\n        return false;\n    }\n\n    return arr.length > 0 && Array.isArray(arr[0]);\n}\n\nfunction buildDefaultSortParseOutput<T extends ObjectLiteral = ObjectLiteral>(\n    options: SortParseOptions<T>,\n) : SortParseOutput {\n    if (options.default) {\n        const output : SortParseOutput = [];\n\n        const flatten = flattenNestedObject(options.default);\n        const keys = Object.keys(flatten);\n\n        for (let i = 0; i < keys.length; i++) {\n            const fieldDetails = getFieldDetails(keys[i]);\n\n            let path : string | undefined;\n            if (fieldDetails.path) {\n                path = fieldDetails.path;\n            } else if (options.defaultPath) {\n                path = options.defaultPath;\n            }\n\n            output.push({\n                key: fieldDetails.name,\n                ...(path ? { path } : {}),\n                value: flatten[keys[i]],\n            });\n        }\n\n        return output;\n    }\n\n    return [];\n}\n\n/**\n * Transform sort data to appreciate data format.\n * @param data\n * @param options\n */\nexport function parseQuerySort<T extends ObjectLiteral = ObjectLiteral>(\n    data: unknown,\n    options?: SortParseOptions<T>,\n) : SortParseOutput {\n    options = options || {};\n\n    // If it is an empty array nothing is allowed\n    if (typeof options.allowed !== 'undefined') {\n        const allowed = flattenParseAllowedOption(options.allowed) as ParseAllowedOption<T>;\n        if (allowed.length === 0) {\n            return buildDefaultSortParseOutput(options);\n        }\n    }\n\n    options.mapping = options.mapping || {};\n\n    /* istanbul ignore next */\n    if (\n        typeof data !== 'string' &&\n        !Array.isArray(data) &&\n        !isObject(data)\n    ) {\n        return buildDefaultSortParseOutput(options);\n    }\n\n    if (\n        typeof options.allowed === 'undefined' &&\n        options.default\n    ) {\n        const flatten = flattenNestedObject(options.default);\n        options.allowed = Object.keys(flatten) as ParseAllowedOption<T>;\n    }\n\n    let parts : string[] = [];\n\n    if (typeof data === 'string') {\n        parts = data.split(',');\n    }\n\n    if (Array.isArray(data)) {\n        parts = data.filter((item) => typeof item === 'string');\n    }\n\n    if (\n        typeof data === 'object' &&\n        data !== null\n    ) {\n        const keys = Object.keys(data);\n        for (let i = 0; i < keys.length; i++) {\n            /* istanbul ignore next */\n            if (\n                !hasOwnProperty(data, keys[i]) ||\n                typeof keys[i] !== 'string' ||\n                typeof data[keys[i]] !== 'string'\n            ) continue;\n\n            const fieldPrefix = (data[keys[i]] as string)\n                .toLowerCase() === 'desc' ? '-' : '';\n\n            parts.push(fieldPrefix + keys[i]);\n        }\n    }\n\n    const items : Record<string, SortParseOutputElement> = {};\n\n    let matched = false;\n\n    for (let i = 0; i < parts.length; i++) {\n        const { value, direction } = parseSortValue(parts[i]);\n        parts[i] = value;\n\n        const key: string = applyMapping(parts[i], options.mapping);\n\n        const fieldDetails = getFieldDetails(key);\n\n        if (\n            typeof options.allowed === 'undefined' &&\n            !isValidFieldName(fieldDetails.name)\n        ) {\n            continue;\n        }\n\n        if (\n            !isFieldPathAllowedByRelations(fieldDetails, options.relations) &&\n            !isFieldNonRelational(fieldDetails)\n        ) {\n            continue;\n        }\n\n        const keyWithAlias : string = buildFieldWithPath(fieldDetails);\n\n        if (\n            typeof options.allowed !== 'undefined' &&\n            !isMultiDimensionalArray(options.allowed) &&\n            !isPathCoveredByParseAllowedOption(options.allowed, [key, keyWithAlias])\n        ) {\n            continue;\n        }\n\n        matched = true;\n\n        let path : string | undefined;\n        if (fieldDetails.path) {\n            path = fieldDetails.path;\n        } else if (options.defaultPath) {\n            path = options.defaultPath;\n        }\n\n        items[keyWithAlias] = {\n            key: fieldDetails.name,\n            ...(path ? { path } : {}),\n            value: direction,\n        };\n    }\n\n    if (!matched) {\n        return buildDefaultSortParseOutput(options);\n    }\n\n    if (isMultiDimensionalArray(options.allowed)) {\n        // eslint-disable-next-line no-labels,no-restricted-syntax\n        outerLoop:\n        for (let i = 0; i < options.allowed.length; i++) {\n            const temp : SortParseOutput = [];\n\n            const keyPaths = flattenParseAllowedOption(options.allowed[i] as string[]);\n\n            for (let j = 0; j < keyPaths.length; j++) {\n                let keyWithAlias : string = keyPaths[j];\n                let key : string;\n\n                const parts = keyWithAlias.split('.');\n                if (parts.length > 1) {\n                    key = parts.pop() as string;\n                } else {\n                    key = keyWithAlias;\n\n                    keyWithAlias = buildKeyPath(key, options.defaultPath);\n                }\n\n                if (\n                    hasOwnProperty(items, key) ||\n                    hasOwnProperty(items, keyWithAlias)\n                ) {\n                    const item = hasOwnProperty(items, key) ?\n                        items[key] :\n                        items[keyWithAlias];\n\n                    temp.push(item);\n                } else {\n                    // eslint-disable-next-line no-labels\n                    continue outerLoop;\n                }\n            }\n\n            return temp;\n        }\n\n        // if we get no match, the sort data is invalid.\n        return [];\n    }\n\n    return Object.values(items);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport {\n    RelationsParseOutput, parseQueryFields, parseQueryFilters, parseQueryPagination, parseQueryRelations, parseQuerySort,\n} from '../../parameter';\nimport {\n    Parameter, URLParameter,\n} from '../../constants';\nimport { ObjectLiteral } from '../../type';\nimport { ParseParameterOptions, ParseParameterOutput } from './type';\n\nexport function parseQueryParameter<\n    P extends `${Parameter}` | `${URLParameter}`,\n    T extends ObjectLiteral = ObjectLiteral,\n    >(\n    key: P,\n    data: unknown,\n    options?: ParseParameterOptions<P, T>,\n    relations?: RelationsParseOutput,\n): ParseParameterOutput<P> {\n    switch (key) {\n        case Parameter.FIELDS:\n        case URLParameter.FIELDS:\n            return (parseQueryFields(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.FIELDS>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.FILTERS:\n        case URLParameter.FILTERS:\n            return (parseQueryFilters(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.FILTERS>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.PAGINATION:\n        case URLParameter.PAGINATION:\n            return (parseQueryPagination(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.PAGINATION>,\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.RELATIONS:\n        case URLParameter.RELATIONS:\n            return (parseQueryRelations(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.RELATIONS>,\n                },\n            ) as ParseParameterOutput<P>);\n        default:\n            return (parseQuerySort(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.SORT>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n    }\n}\n\nfunction invalidToEmptyObject<V>(\n    value: V | boolean,\n): NonNullable<V> {\n    return typeof value === 'boolean' ||\n        typeof value === 'undefined' ?\n        {} as NonNullable<V> :\n        value as NonNullable<V>;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\n\nexport function buildQueryParameterOptions<T extends Record<string, any>>(\n    input?: T | boolean,\n) : T {\n    if (isObject(input)) {\n        return input;\n    }\n\n    return {} as T;\n}\n\nexport function isQueryParameterEnabled<T extends Record<string, any>>(\n    input?: T | boolean,\n) : boolean {\n    if (typeof input === 'boolean') {\n        return input;\n    }\n\n    return true;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { DEFAULT_ID } from '../../../constants';\n\nexport function buildFieldDomainRecords(\n    data?: Record<string, string[]> | string[],\n): Record<string, string[]> {\n    if (typeof data === 'undefined') {\n        return {};\n    }\n\n    let domainFields: Record<string, string[]> = {};\n\n    if (Array.isArray(data)) {\n        domainFields[DEFAULT_ID] = data;\n    } else {\n        domainFields = data;\n    }\n\n    return domainFields;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ObjectLiteral } from '../type';\nimport { BuildInput } from './type';\nimport {\n    buildQueryFields,\n    buildQueryFilters,\n    buildQueryRelations,\n    buildQuerySort,\n    mergeQueryFields,\n    mergeQueryFilters,\n    mergeQueryPagination,\n    mergeQueryRelations,\n    mergeQuerySort,\n} from '../parameter';\nimport { Parameter, URLParameter } from '../constants';\nimport {\n    buildURLQueryString,\n} from '../utils';\n\nexport function buildQuery<T extends ObjectLiteral = ObjectLiteral>(\n    input?: BuildInput<T>,\n) : string {\n    if (!input) {\n        return '';\n    }\n\n    const query: { [key in URLParameter]?: unknown } = {};\n\n    if (\n        typeof input[Parameter.FIELDS] !== 'undefined' ||\n        typeof input[URLParameter.FIELDS] !== 'undefined'\n    ) {\n        query[URLParameter.FIELDS] = mergeQueryFields(\n            buildQueryFields(input[Parameter.FIELDS]),\n            buildQueryFields(input[URLParameter.FIELDS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.FILTERS] !== 'undefined' ||\n        typeof input[URLParameter.FILTERS] !== 'undefined'\n    ) {\n        query[URLParameter.FILTERS] = mergeQueryFilters(\n            buildQueryFilters(input[Parameter.FILTERS]),\n            buildQueryFilters(input[URLParameter.FILTERS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.PAGINATION] !== 'undefined' ||\n        typeof input[URLParameter.PAGINATION] !== 'undefined'\n    ) {\n        query[URLParameter.PAGINATION] = mergeQueryPagination(\n            input[Parameter.PAGINATION],\n            input[URLParameter.PAGINATION],\n        );\n    }\n\n    if (\n        typeof input[Parameter.RELATIONS] !== 'undefined' ||\n        typeof input[URLParameter.RELATIONS] !== 'undefined'\n    ) {\n        query[URLParameter.RELATIONS] = mergeQueryRelations(\n            buildQueryRelations(input[Parameter.RELATIONS]),\n            buildQueryRelations(input[URLParameter.RELATIONS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.SORT] !== 'undefined' ||\n        typeof input[URLParameter.SORT] !== 'undefined'\n    ) {\n        query[URLParameter.SORT] = mergeQuerySort(\n            buildQuerySort(input[Parameter.SORT]),\n            buildQuerySort(input[URLParameter.SORT]),\n        );\n    }\n\n    return buildURLQueryString(query);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function buildURLQueryString(data?: any, withQuestionMark = true) {\n    if (typeof data === 'undefined' || data === null) return '';\n\n    // If the data is already a string, return it as-is\n    if (typeof (data) === 'string') return data;\n\n    // Create a query array to hold the key/value pairs\n    const query = [];\n\n    // Loop through the data object\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        if (Object.prototype.hasOwnProperty.call(data, keys[i])) {\n            let value = data[keys[i]];\n\n            if (value && typeof value === 'object' && value.constructor === Array) {\n                value = value.join(',');\n            }\n\n            if (value && typeof value === 'object' && value.constructor === Object) {\n                const valueKeys = Object.keys(value);\n                for (let j = 0; j < valueKeys.length; j++) {\n                    let v: any = value[valueKeys[j]];\n\n                    if (v && typeof v === 'object' && v.constructor === Array) {\n                        v = v.join(',');\n                    }\n\n                    query.push(`${encodeURIComponent(`${keys[i]}[${valueKeys[j]}]`)}=${encodeURIComponent(v)}`);\n                }\n\n                continue;\n            }\n\n            // Encode each key and value, concatenate them into a string, and push them to the array\n            query.push(`${encodeURIComponent(keys[i])}=${encodeURIComponent(value)}`);\n        }\n    }\n\n    // Join each item in the array with a `&` and return the resulting string\n    return (withQuestionMark ? '?' : '') + query.join('&');\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport {\n    FieldsParseOutput,\n    FiltersParseOutput,\n    PaginationParseOutput,\n    RelationsParseOutput,\n    SortParseOutput,\n} from '../parameter';\nimport { Parameter, URLParameter } from '../constants';\nimport { ObjectLiteral } from '../type';\nimport { buildQueryParameterOptions, isQueryParameterEnabled, parseQueryParameter } from './parameter';\nimport { ParseInput, ParseOptions, ParseOutput } from './type';\n\nexport function parseQuery<T extends ObjectLiteral = ObjectLiteral>(\n    input: ParseInput,\n    options: ParseOptions<T> = {},\n) : ParseOutput {\n    options = options || {};\n\n    const mergeWithGlobalOptions = <T extends {[key: string]: any} & {defaultPath?: string} >(data?: T) : T => {\n        if (typeof data !== 'undefined') {\n            if (options.defaultPath) {\n                data.defaultPath = options.defaultPath;\n            }\n        }\n\n        return data || {} as T;\n    };\n\n    const output : ParseOutput = {};\n    if (options.defaultPath) {\n        output.defaultPath = options.defaultPath;\n    }\n\n    let relations : RelationsParseOutput | undefined;\n\n    const keys : Parameter[] = [\n        // relations must be first parameter\n        Parameter.RELATIONS,\n\n        Parameter.FIELDS,\n        Parameter.FILTERS,\n        Parameter.PAGINATION,\n        Parameter.SORT,\n    ];\n\n    for (let i = 0; i < keys.length; i++) {\n        const key : Parameter = keys[i];\n\n        switch (key) {\n            case Parameter.RELATIONS: {\n                const value = input[Parameter.RELATIONS] || input[URLParameter.RELATIONS];\n                if (value && isQueryParameterEnabled(options[Parameter.RELATIONS])) {\n                    relations = parseQueryParameter(\n                        key,\n                        value,\n                        buildQueryParameterOptions(options[Parameter.RELATIONS]),\n                    );\n\n                    output[Parameter.RELATIONS] = relations;\n                }\n                break;\n            }\n            case Parameter.FIELDS: {\n                const value = input[Parameter.FIELDS] || input[URLParameter.FIELDS];\n                if (value && isQueryParameterEnabled(options[Parameter.FIELDS])) {\n                    output[Parameter.FIELDS] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FIELDS])),\n                        relations,\n                    ) as FieldsParseOutput;\n                }\n                break;\n            }\n            case Parameter.FILTERS: {\n                const value = input[Parameter.FILTERS] || input[URLParameter.FILTERS];\n                if (value && isQueryParameterEnabled(options[Parameter.FILTERS])) {\n                    output[Parameter.FILTERS] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FILTERS])),\n                        relations,\n                    ) as FiltersParseOutput;\n                }\n                break;\n            }\n            case Parameter.PAGINATION: {\n                const value = input[Parameter.PAGINATION] || input[URLParameter.PAGINATION];\n                if (value && isQueryParameterEnabled(options[Parameter.PAGINATION])) {\n                    output[Parameter.PAGINATION] = parseQueryParameter(\n                        key,\n                        value,\n                        buildQueryParameterOptions(options[Parameter.PAGINATION]),\n                        relations,\n                    ) as PaginationParseOutput;\n                }\n                break;\n            }\n            case Parameter.SORT: {\n                const value = input[Parameter.SORT] || input[URLParameter.SORT];\n                if (value && isQueryParameterEnabled(options[Parameter.SORT])) {\n                    output[Parameter.SORT] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.SORT])),\n                        relations,\n                    ) as SortParseOutput;\n                }\n                break;\n            }\n        }\n    }\n\n    return output;\n}\n"],"names":["Parameter","URLParameter","DEFAULT_ID","buildKeyPath","key","prefix","flattenToKeyPathArray","input","options","output","transformer","result","Array","isArray","i","length","j","push","keys","Object","value","data","groupArrayByKeyPath","pathItems","parts","split","name","pop","join","prototype","hasOwnProperty","call","_extends","obj","prop","flattenNestedObject","prefixParts","destinationKey","applyMapping","map","onlyKey","run","shift","found","rest","copy","last","unshift","getFieldDetails","field","path","undefined","isFieldNonRelational","isFieldPathAllowedByRelations","includes","details","some","include","buildFieldWithPath","buildQueryFields","mergeQueryFields","target","source","createMerger","array","arrayDistinct","merge","FieldOperator","FilterComparisonOperator","FilterInputOperatorValue","SortDirection","flattenParseAllowedOption","isPathCoveredByParseAllowedOption","paths","items","indexOf","removeFieldInputOperator","firstCharacter","substring","INCLUDE","EXCLUDE","transformFieldsInput","fields","default","included","excluded","operator","character","parseFieldsInput","isValidFieldName","test","parseQueryFields","defaultDomainFields","allowedDomainFields","allowed","domainFields","isObject","mapping","reverseMapping","record","buildReverseRecord","relations","transformed","filter","from","Set","index","splice","destPath","defaultPath","buildQueryFilters","mergeQueryFilters","transformFilterValue","lower","trim","toLowerCase","num","Number","isNaN","n","matchOperator","position","match","parseFilterValue","IN","negation","NEGATION","NOT_IN","LIKE","NOT_LIKE","LESS_THAN_EQUAL","LESS_THAN","MORE_THAN_EQUAL","GREATER_THAN_EQUAL","MORE_THAN","GREATER_THAN","NOT_EQUAL","EQUAL","transformFiltersParseOutputElement","element","buildDefaultFiltersParseOutput","inputKeys","defaultByElement","values","flatten","fieldDetails","parseQueryFilters","fullKey","validate","mergeQueryPagination","finalizePagination","maxLimit","limit","offset","parseQueryPagination","pagination","parseInt","buildQueryRelations","mergeQueryRelations","mergeArrays","includeParents","parseQueryRelations","pathMapping","item","isValidRelationPath","parentIncludes","parent","startsWith","buildQuerySort","ASC","DESC","mergeQuerySort","parseSortValue","direction","isMultiDimensionalArray","arr","buildDefaultSortParseOutput","parseQuerySort","fieldPrefix","matched","keyWithAlias","outerLoop","temp","keyPaths","parseQueryParameter","FIELDS","invalidToEmptyObject","FILTERS","PAGINATION","RELATIONS","buildQueryParameterOptions","isQueryParameterEnabled","query","SORT","withQuestionMark","constructor","valueKeys","v","encodeURIComponent","buildURLQueryString","mergeWithGlobalOptions"],"mappings":"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"}