import { Flatten, KeyWithOptionalPrefix, NestedKeys, OnlyObject, SimpleKeys } from '../../type';
import { RelationsParseOutput } from '../relations';
import { ParseAllowedOption } from '../type';
export declare enum SortDirection {
    ASC = "ASC",
    DESC = "DESC"
}
type SortWithOperator<T extends string> = KeyWithOptionalPrefix<T, '-'>;
export type SortBuildInput<T extends Record<string, any>> = {
    [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ? SortBuildInput<Flatten<T[K]>> : `${SortDirection}`;
} | (SortWithOperator<SimpleKeys<T>>[] | {
    [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ? SortBuildInput<Flatten<T[K]>> : `${SortDirection}`;
})[] | SortWithOperator<NestedKeys<T>>[] | SortWithOperator<NestedKeys<T>>;
export type SortParseDefaultOption<T extends Record<string, any>> = {
    [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ? SortParseDefaultOption<Flatten<T[K]>> : `${SortDirection}`;
} | {
    [K in NestedKeys<T>]?: `${SortDirection}`;
};
export type SortParseOptions<T extends Record<string, any> = Record<string, any>> = {
    allowed?: ParseAllowedOption<T>;
    mapping?: Record<string, string>;
    default?: SortParseDefaultOption<T>;
    defaultPath?: string;
    relations?: RelationsParseOutput;
};
export type SortParseOutputElement = {
    key: string;
    value: `${SortDirection}`;
    path?: string;
};
export type SortParseOutput = SortParseOutputElement[];
export {};
//# sourceMappingURL=type.d.ts.map