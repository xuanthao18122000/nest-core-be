{"version":3,"file":"index.mjs","sources":["../src/constants.ts","../src/utils/array.ts","../src/utils/object.ts","../src/utils/mapping.ts","../src/utils/field.ts","../src/utils/relation.ts","../src/parameter/fields/build.ts","../src/parameter/fields/constants.ts","../src/parameter/filters/constants.ts","../src/parameter/sort/type.ts","../src/parameter/utils/parse/allowed-option.ts","../src/parameter/fields/utils/domain.ts","../src/parameter/fields/utils/input.ts","../src/parameter/fields/utils/name.ts","../src/parameter/fields/parse.ts","../src/parameter/filters/build.ts","../src/parameter/filters/utils/value.ts","../src/parameter/filters/utils/operator.ts","../src/parameter/filters/parse.ts","../src/parameter/pagination/build.ts","../src/parameter/pagination/parse.ts","../src/parameter/relations/build.ts","../src/parameter/relations/utils/parents.ts","../src/parameter/relations/parse.ts","../src/parameter/relations/utils/path.ts","../src/parameter/sort/build.ts","../src/parameter/sort/utils.ts","../src/parameter/sort/parse.ts","../src/build/module.ts","../src/utils/url.ts","../src/parse/parameter/module.ts","../src/parse/parameter/utils.ts","../src/parse/module.ts"],"sourcesContent":["/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\n// -----------------------------------------------------------\n\nexport enum Parameter {\n    FILTERS = 'filters',\n    FIELDS = 'fields',\n    PAGINATION = 'pagination',\n    RELATIONS = 'relations',\n    SORT = 'sort',\n}\n\n// -----------------------------------------------------------\n\nexport enum URLParameter {\n    FILTERS = 'filter',\n    FIELDS = 'fields',\n    PAGINATION = 'page',\n    RELATIONS = 'include',\n    SORT = 'sort',\n}\n\n// -----------------------------------------------------------\n\nexport const DEFAULT_ID = '__DEFAULT__';\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { DEFAULT_ID } from '../constants';\n\nexport function buildKeyPath(key: string, prefix?: string) {\n    if (typeof prefix === 'string') {\n        return `${prefix}.${key}`;\n    }\n\n    return key;\n}\n\ntype Options = {\n    transformer?: (\n        input: unknown,\n        output: string[],\n        prefix?: string\n    ) => boolean | undefined\n};\n\nexport function flattenToKeyPathArray(\n    input: unknown,\n    options?: Options,\n    prefix?: string,\n): string[] {\n    options = options || {};\n\n    const output: string[] = [];\n\n    if (options.transformer) {\n        const result = options.transformer(input, output, prefix);\n        if (typeof result !== 'undefined' && !!result) {\n            return output;\n        }\n    }\n\n    if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (options.transformer) {\n                const result = options.transformer(input[i], output, prefix);\n                if (typeof result !== 'undefined' && !!result) {\n                    return output;\n                }\n            }\n\n            if (Array.isArray(input[i])) {\n                for (let j = 0; j < input[i].length; j++) {\n                    const key = buildKeyPath(input[i][j], prefix);\n                    output.push(key);\n                }\n\n                continue;\n            }\n\n            if (typeof input[i] === 'string') {\n                output.push(buildKeyPath(input[i], prefix));\n\n                continue;\n            }\n\n            if (typeof input[i] === 'object') {\n                const keys = Object.keys(input[i]);\n                for (let j = 0; j < keys.length; j++) {\n                    const value = buildKeyPath(keys[j] as string, prefix);\n                    const data = flattenToKeyPathArray(input[i][keys[j]], options, value);\n                    if (data.length === 0) {\n                        output.push(value);\n                    } else {\n                        output.push(...data);\n                    }\n                }\n            }\n        }\n\n        return output;\n    }\n\n    if (\n        typeof input === 'object' &&\n        input !== null\n    ) {\n        const keys = Object.keys(input);\n        for (let i = 0; i < keys.length; i++) {\n            const value = buildKeyPath(keys[i], prefix);\n            const data = flattenToKeyPathArray((input as Record<string, any>)[keys[i]], options, value);\n            if (data.length === 0) {\n                output.push(value);\n            } else {\n                output.push(...data);\n            }\n        }\n\n        return output;\n    }\n\n    if (\n        typeof input === 'string'\n    ) {\n        const value = buildKeyPath(input, prefix);\n        output.push(value);\n\n        return output;\n    }\n\n    return output;\n}\n\nexport function groupArrayByKeyPath(input: string[]): Record<string, string[]> {\n    const pathItems: Record<string, string[]> = {};\n\n    for (let i = 0; i < input.length; i++) {\n        const parts = input[i].split('.');\n\n        let key: string;\n        let name: string;\n        if (parts.length === 1) {\n            key = DEFAULT_ID;\n            name = input[i];\n        } else {\n            name = parts.pop() as string;\n            key = parts.join('.');\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(pathItems, key)) {\n            pathItems[key] = [];\n        }\n\n        pathItems[key].push(name);\n    }\n\n    return pathItems;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function hasOwnProperty<\n    X extends Record<string, any>,\n    Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\ntype Options = {\n    transformer?: (\n        input: unknown,\n        output: Record<string, any>,\n        key: string\n    ) => boolean | undefined\n};\n\nexport function flattenNestedObject(\n    data: Record<string, any>,\n    options?: Options,\n    prefixParts?: string[],\n): Record<string, any> {\n    options = options || {};\n    prefixParts = prefixParts || [];\n\n    let output: Record<string, string> = {};\n\n    if (options.transformer) {\n        const result = options.transformer(data, output, prefixParts.join('.'));\n        if (typeof result !== 'undefined' && !!result) {\n            return output;\n        }\n    }\n\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (options.transformer) {\n            const result = options.transformer(data[key], output, [...prefixParts, key].join('.'));\n            if (typeof result !== 'undefined' && !!result) {\n                continue;\n            }\n        }\n\n        if (\n            typeof data[key] === 'object' &&\n            data[key]\n        ) {\n            output = { ...output, ...flattenNestedObject(data[key], options, [...prefixParts, key]) };\n\n            continue;\n        }\n\n        const destinationKey = [...prefixParts, key].join('.');\n\n        if (\n            typeof data[key] === 'boolean' ||\n            typeof data[key] === 'string' ||\n            typeof data[key] === 'number' ||\n            typeof data[key] === 'undefined' ||\n            data[key] === null ||\n            Array.isArray(data[key])\n        ) {\n            output[destinationKey] = data[key];\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { hasOwnProperty } from './object';\n\nexport function applyMapping(\n    name: string,\n    map?: Record<string, string>,\n    onlyKey?: boolean,\n) {\n    if (typeof map === 'undefined') {\n        return name;\n    }\n\n    let parts = name.split('.');\n\n    const output = [];\n    let run = true;\n    while (run) {\n        const value = parts.shift();\n        if (typeof value === 'undefined') {\n            run = false;\n            break;\n        }\n\n        if (hasOwnProperty(map, value)) {\n            output.push(map[value]);\n        } else {\n            let found = false;\n\n            const rest : string[] = [];\n            const copy = [...parts];\n            while (copy.length > 0) {\n                const key = [value, ...copy].join('.');\n                if (hasOwnProperty(map, key)) {\n                    output.push(map[key]);\n                    found = true;\n                    break;\n                } else {\n                    const last = copy.pop();\n                    if (last) {\n                        rest.unshift(last);\n                    }\n                }\n            }\n\n            if (found) {\n                parts = rest;\n            } else {\n                output.push(value);\n            }\n        }\n    }\n\n    if (onlyKey) {\n        return output.pop() || name;\n    }\n\n    if (output.length === 0) {\n        return name;\n    }\n\n    return output.join('.');\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FieldDetails } from './type';\n\nexport function getFieldDetails(field: string) : FieldDetails {\n    const parts : string[] = field.split('.');\n\n    return {\n        name: parts.pop() as string,\n        path: parts.length > 0 ? parts.join('.') : undefined,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { RelationsParseOutput } from '../parameter';\nimport { getFieldDetails } from './field';\nimport { FieldDetails } from './type';\n\nexport function isFieldNonRelational(field: string | FieldDetails) {\n    const details = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    return typeof details.path === 'undefined';\n}\n\nexport function isFieldPathAllowedByRelations(\n    field: string | Pick<FieldDetails, 'path'>,\n    includes?: RelationsParseOutput,\n) : boolean {\n    if (typeof includes === 'undefined') {\n        return true;\n    }\n\n    const details : Pick<FieldDetails, 'path'> = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    if (\n        typeof details.path === 'undefined'\n    ) {\n        return true;\n    }\n\n    return includes.some(\n        (include) => include.key === details.path,\n    );\n}\n\nexport function buildFieldWithPath(\n    field: string | FieldDetails,\n    path?: string,\n) : string {\n    const details = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    return details.path || path ?\n        `${details.path || path}.${details.name}` :\n        details.name;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { createMerger } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport { FieldsBuildInput } from './type';\nimport { flattenToKeyPathArray, groupArrayByKeyPath } from '../../utils';\n\nexport function buildQueryFields<T extends ObjectLiteral = ObjectLiteral>(\n    input?: FieldsBuildInput<T>,\n) : Record<string, string[]> | string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    const data = groupArrayByKeyPath(flattenToKeyPathArray(input));\n\n    const keys = Object.keys(data);\n    if (keys.length === 1) {\n        return data[keys[0]];\n    }\n\n    return data;\n}\n\nexport function mergeQueryFields(\n    target: Record<string, string[]> | string[],\n    source: Record<string, string[]> | string[],\n): Record<string, string[]> | string[] {\n    if (Array.isArray(target)) {\n        target = groupArrayByKeyPath(target);\n    }\n\n    if (Array.isArray(source)) {\n        source = groupArrayByKeyPath(source);\n    }\n\n    const merge = createMerger({\n        array: true,\n        arrayDistinct: true,\n    });\n\n    const data = merge({}, target, source);\n\n    const keys = Object.keys(data);\n    if (keys.length === 1) {\n        return data[keys[0]];\n    }\n\n    return data;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum FieldOperator {\n    INCLUDE = '+',\n    EXCLUDE = '-',\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum FilterComparisonOperator {\n    EQUAL = '$eq',\n    NOT_EQUAL = '$ne',\n    LIKE = '$l',\n    NOT_LIKE = '$nl',\n    LESS_THAN_EQUAL = '$lte',\n    LESS_THAN = '$lt',\n    GREATER_THAN_EQUAL = '$gte',\n    GREATER_THAN = '$gt',\n    IN = '$in',\n    NOT_IN = '$nin',\n}\n\nexport enum FilterInputOperatorValue {\n    NEGATION = '!',\n    LIKE = '~',\n    LESS_THAN_EQUAL = '<=',\n    LESS_THAN = '<',\n    MORE_THAN_EQUAL = '>=',\n    MORE_THAN = '>',\n    IN = ',',\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport {\n    Flatten, KeyWithOptionalPrefix, NestedKeys, OnlyObject, SimpleKeys,\n} from '../../type';\nimport { RelationsParseOutput } from '../relations';\nimport {\n    ParseAllowedOption,\n} from '../type';\n\nexport enum SortDirection {\n    ASC = 'ASC',\n    DESC = 'DESC',\n}\n\n// -----------------------------------------------------------\n// Build\n// -----------------------------------------------------------\n\ntype SortWithOperator<T extends string> = KeyWithOptionalPrefix<T, '-'>;\n\nexport type SortBuildInput<T extends Record<string, any>> =\n    {\n        [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n            SortBuildInput<Flatten<T[K]>> :\n            `${SortDirection}`\n    }\n    |\n    (\n        SortWithOperator<SimpleKeys<T>>[] |\n        {\n            [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n                SortBuildInput<Flatten<T[K]>> :\n                `${SortDirection}`\n        }\n    )[]\n    |\n    SortWithOperator<NestedKeys<T>>[] |\n    SortWithOperator<NestedKeys<T>>;\n\n// -----------------------------------------------------------\n// Parse\n// -----------------------------------------------------------\n\nexport type SortParseDefaultOption<T extends Record<string, any>> = {\n    [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n        SortParseDefaultOption<Flatten<T[K]>> :\n        `${SortDirection}`\n} | {\n    [K in NestedKeys<T>]?: `${SortDirection}`\n};\n\nexport type SortParseOptions<\n    T extends Record<string, any> = Record<string, any>,\n    > = {\n        allowed?: ParseAllowedOption<T>,\n        mapping?: Record<string, string>,\n        default?: SortParseDefaultOption<T>,\n        defaultPath?: string,\n        relations?: RelationsParseOutput,\n    };\nexport type SortParseOutputElement = {\n    key: string,\n    value: `${SortDirection}`,\n    path?: string\n};\nexport type SortParseOutput = SortParseOutputElement[];\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { NestedKeys, NestedResourceKeys, ObjectLiteral } from '../../../type';\nimport { flattenToKeyPathArray } from '../../../utils';\nimport { ParseAllowedOption } from '../../type';\n\nexport function flattenParseAllowedOption<T extends ObjectLiteral>(\n    input?: ParseAllowedOption<T>,\n) : string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    return flattenToKeyPathArray(input);\n}\n\nexport function isPathCoveredByParseAllowedOption<T extends ObjectLiteral>(\n    input: ParseAllowedOption<T> |\n    NestedKeys<T>[] |\n    NestedResourceKeys<T>[],\n    path: string | string[],\n) : boolean {\n    const paths = Array.isArray(path) ? path : [path];\n\n    const items = flattenToKeyPathArray(input);\n    for (let i = 0; i < items.length; i++) {\n        if (paths.indexOf(items[i]) !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { DEFAULT_ID } from '../../../constants';\n\nexport function buildFieldDomainRecords(\n    data?: Record<string, string[]> | string[],\n): Record<string, string[]> {\n    if (typeof data === 'undefined') {\n        return {};\n    }\n\n    let domainFields: Record<string, string[]> = {};\n\n    if (Array.isArray(data)) {\n        domainFields[DEFAULT_ID] = data;\n    } else {\n        domainFields = data;\n    }\n\n    return domainFields;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FieldsInputTransformed } from '../type';\nimport { FieldOperator } from '../constants';\n\nexport function removeFieldInputOperator(field: string) {\n    const firstCharacter = field.substring(0, 1);\n\n    return firstCharacter === FieldOperator.INCLUDE ||\n        firstCharacter === FieldOperator.EXCLUDE ?\n        field.substring(1) :\n        field;\n}\n\nexport function transformFieldsInput(\n    fields: string[],\n): FieldsInputTransformed {\n    const output: FieldsInputTransformed = {\n        default: [],\n        included: [],\n        excluded: [],\n    };\n\n    for (let i = 0; i < fields.length; i++) {\n        let operator: FieldOperator | undefined;\n\n        const character = fields[i].substring(0, 1);\n\n        if (character === FieldOperator.INCLUDE) {\n            operator = FieldOperator.INCLUDE;\n        } else if (character === FieldOperator.EXCLUDE) {\n            operator = FieldOperator.EXCLUDE;\n        }\n\n        if (operator) {\n            fields[i] = fields[i].substring(1);\n\n            switch (operator) {\n                case FieldOperator.INCLUDE: {\n                    output.included.push(fields[i]);\n                    break;\n                }\n                case FieldOperator.EXCLUDE: {\n                    output.excluded.push(fields[i]);\n                    break;\n                }\n            }\n        } else {\n            output.default.push(fields[i]);\n        }\n    }\n\n    return output;\n}\n\nexport function parseFieldsInput(input: unknown): string[] {\n    let output: string[] = [];\n\n    if (typeof input === 'string') {\n        output = input.split(',');\n    } else if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (typeof input[i] === 'string') {\n                output.push(input[i]);\n            }\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isValidFieldName(input: string) : boolean {\n    return /^[a-zA-Z_][a-zA-Z0-9_]*$/gu.test(input);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject, merge } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport {\n    applyMapping, buildFieldWithPath, groupArrayByKeyPath, hasOwnProperty, isFieldPathAllowedByRelations,\n} from '../../utils';\nimport { flattenParseAllowedOption } from '../utils';\nimport {\n    FieldsInputTransformed, FieldsParseOptions, FieldsParseOutput,\n} from './type';\nimport {\n    isValidFieldName,\n    parseFieldsInput, removeFieldInputOperator,\n    transformFieldsInput,\n} from './utils';\nimport { DEFAULT_ID } from '../../constants';\n\n// --------------------------------------------------\n\nfunction buildReverseRecord(\n    record: Record<string, string>,\n) : Record<string, string> {\n    const keys = Object.keys(record);\n    const output : Record<string, string> = {};\n\n    for (let i = 0; i < keys.length; i++) {\n        output[record[keys[i]]] = keys[i];\n    }\n\n    return output;\n}\n\nexport function parseQueryFields<T extends ObjectLiteral = ObjectLiteral>(\n    input: unknown,\n    options?: FieldsParseOptions<T>,\n) : FieldsParseOutput {\n    options = options || {};\n\n    const defaultDomainFields = groupArrayByKeyPath(\n        flattenParseAllowedOption(options.default),\n    );\n\n    const allowedDomainFields = groupArrayByKeyPath(\n        flattenParseAllowedOption(options.allowed),\n    );\n\n    const domainFields = merge(\n        {},\n        defaultDomainFields,\n        allowedDomainFields,\n    );\n\n    let keys : string[] = Object.keys(domainFields);\n\n    // If it is an empty array nothing is allowed\n    if (\n        (\n            typeof options.default !== 'undefined' ||\n            typeof options.allowed !== 'undefined'\n        ) &&\n        keys.length === 0\n    ) {\n        return [];\n    }\n\n    let data : Record<string, any> = {\n        [DEFAULT_ID]: [],\n    };\n\n    if (isObject(input)) {\n        data = input;\n    } else if (typeof input === 'string') {\n        data = { [DEFAULT_ID]: input };\n    } else if (Array.isArray(input)) {\n        data = { [DEFAULT_ID]: input };\n    }\n\n    options.mapping = options.mapping || {};\n    const reverseMapping = buildReverseRecord(options.mapping);\n\n    if (keys.length === 0) {\n        keys = Object.keys(data);\n    }\n\n    const output : FieldsParseOutput = [];\n\n    for (let i = 0; i < keys.length; i++) {\n        const path = keys[i];\n\n        if (\n            !isFieldPathAllowedByRelations({ path }, options.relations) &&\n            path !== DEFAULT_ID\n        ) {\n            continue;\n        }\n\n        let fields : string[] = [];\n\n        if (hasOwnProperty(data, path)) {\n            fields = parseFieldsInput(data[path]);\n        } else if (\n            hasOwnProperty(reverseMapping, path) &&\n            hasOwnProperty(data, reverseMapping[path])\n        ) {\n            fields = parseFieldsInput(data[reverseMapping[path]]);\n        }\n\n        let transformed : FieldsInputTransformed = {\n            default: [],\n            included: [],\n            excluded: [],\n        };\n\n        if (fields.length > 0) {\n            for (let j = 0; j < fields.length; j++) {\n                fields[j] = applyMapping(\n                    buildFieldWithPath({ name: fields[j], path }),\n                    options.mapping,\n                    true,\n                );\n            }\n\n            if (hasOwnProperty(domainFields, path)) {\n                fields = fields.filter((field) => domainFields[path].indexOf(\n                    removeFieldInputOperator(field),\n                ) !== -1);\n            } else {\n                fields = fields.filter((field) => isValidFieldName(removeFieldInputOperator(field)));\n            }\n\n            transformed = transformFieldsInput(\n                fields,\n            );\n        }\n\n        if (\n            transformed.default.length === 0 &&\n            hasOwnProperty(defaultDomainFields, path)\n        ) {\n            transformed.default = defaultDomainFields[path];\n        }\n\n        if (\n            transformed.included.length === 0 &&\n            transformed.default.length === 0 &&\n            hasOwnProperty(allowedDomainFields, path)\n        ) {\n            transformed.default = allowedDomainFields[path];\n        }\n\n        transformed.default = Array.from(new Set([\n            ...transformed.default,\n            ...transformed.included,\n        ]));\n\n        for (let j = 0; j < transformed.excluded.length; j++) {\n            const index = transformed.default.indexOf(transformed.excluded[j]);\n            if (index !== -1) {\n                transformed.default.splice(index, 1);\n            }\n        }\n\n        if (transformed.default.length > 0) {\n            for (let j = 0; j < transformed.default.length; j++) {\n                let destPath : string | undefined;\n                if (path !== DEFAULT_ID) {\n                    destPath = path;\n                } else if (options.defaultPath) {\n                    destPath = options.defaultPath;\n                }\n\n                output.push({\n                    key: transformed.default[j],\n                    ...(destPath ? { path: destPath } : {}),\n                });\n            }\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { merge } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport { FiltersBuildInput } from './type';\nimport { flattenNestedObject } from '../../utils';\n\nexport function buildQueryFilters<T extends ObjectLiteral = ObjectLiteral>(\n    data?: FiltersBuildInput<T>,\n) : Record<string, any> {\n    if (typeof data === 'undefined') {\n        return {};\n    }\n\n    return flattenNestedObject(data, {\n        transformer: (input, output, key) => {\n            if (typeof input === 'undefined') {\n                output[key] = null;\n\n                return true;\n            }\n\n            if (Array.isArray(input)) {\n                // preserve null values\n                const data : string[] = [];\n                for (let i = 0; i < input.length; i++) {\n                    if (input[i] === null) {\n                        input[i] = 'null';\n                    }\n\n                    if (typeof input[i] === 'number') {\n                        input[i] = `${input[i]}`;\n                    }\n\n                    if (typeof input[i] === 'string') {\n                        data.push(input[i]);\n                    }\n                }\n\n                output[key] = data.join(',');\n\n                return true;\n            }\n\n            return undefined;\n        },\n    });\n}\n\nexport function mergeQueryFilters(\n    target?: Record<string, any>,\n    source?: Record<string, any>,\n) : Record<string, any> {\n    return merge({}, target || {}, source || {});\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FilterValueSimple } from '../type';\n\nexport function transformFilterValue(input: FilterValueSimple) : FilterValueSimple {\n    if (typeof input === 'string') {\n        input = input.trim();\n        const lower = input.toLowerCase();\n\n        if (lower === 'true') {\n            return true;\n        }\n\n        if (lower === 'false') {\n            return false;\n        }\n\n        if (lower === 'null') {\n            return null;\n        }\n\n        if (input.length === 0) {\n            return input;\n        }\n\n        const num = Number(input);\n        if (!Number.isNaN(num)) {\n            return num;\n        }\n\n        const parts = input.split(',');\n        if (parts.length > 1) {\n            return transformFilterValue(parts);\n        }\n    }\n\n    if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            input[i] = transformFilterValue(input[i]) as string | number;\n        }\n\n        return (input as unknown[])\n            .filter((n) => n === 0 || n === null || !!n) as FilterValueSimple;\n    }\n\n    if (typeof input === 'undefined' || input === null) {\n        return null;\n    }\n\n    return input;\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FilterComparisonOperator, FilterInputOperatorValue } from '../constants';\nimport { FilterValueSimple } from '../type';\n\nfunction matchOperator(key: string, value: FilterValueSimple, position: 'start' | 'end' | 'global') : FilterValueSimple | undefined {\n    if (typeof value === 'string') {\n        switch (position) {\n            case 'start': {\n                if (value.substring(0, key.length) === key) {\n                    return value.substring(key.length);\n                }\n                break;\n            }\n            case 'end': {\n                if (value.substring(0 - key.length) === key) {\n                    return value.substring(0, value.length - key.length - 1);\n                }\n                break;\n            }\n        }\n\n        return undefined;\n    }\n\n    if (Array.isArray(value)) {\n        let match = false;\n        for (let i = 0; i < value.length; i++) {\n            const output = matchOperator(key, value[i], position);\n            if (typeof output !== 'undefined') {\n                match = true;\n                value[i] = output as string | number;\n            }\n        }\n\n        if (match) {\n            return value;\n        }\n    }\n\n    return undefined;\n}\n\nexport function parseFilterValue(input: FilterValueSimple) : {\n    operator: `${FilterComparisonOperator}`,\n    value: FilterValueSimple\n} {\n    if (\n        typeof input === 'string' &&\n        input.includes(FilterInputOperatorValue.IN)\n    ) {\n        input = input.split(FilterInputOperatorValue.IN);\n    }\n\n    let negation = false;\n\n    let value = matchOperator(FilterInputOperatorValue.NEGATION, input, 'start');\n    if (typeof value !== 'undefined') {\n        negation = true;\n        input = value;\n    }\n\n    if (Array.isArray(input)) {\n        return {\n            value: input,\n            operator: negation ?\n                FilterComparisonOperator.NOT_IN :\n                FilterComparisonOperator.IN,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LIKE, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: negation ?\n                FilterComparisonOperator.NOT_LIKE :\n                FilterComparisonOperator.LIKE,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LESS_THAN_EQUAL, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.LESS_THAN_EQUAL,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LESS_THAN, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.LESS_THAN,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.MORE_THAN_EQUAL, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.GREATER_THAN_EQUAL,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.MORE_THAN, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.GREATER_THAN,\n        };\n    }\n\n    return {\n        value: input,\n        operator: negation ?\n            FilterComparisonOperator.NOT_EQUAL :\n            FilterComparisonOperator.EQUAL,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { NestedKeys, ObjectLiteral } from '../../type';\nimport {\n    FieldDetails,\n    applyMapping,\n    buildFieldWithPath,\n    flattenNestedObject,\n    getFieldDetails,\n    hasOwnProperty, isFieldNonRelational, isFieldPathAllowedByRelations,\n} from '../../utils';\nimport { isValidFieldName } from '../fields';\nimport { ParseAllowedOption } from '../type';\nimport { flattenParseAllowedOption, isPathCoveredByParseAllowedOption } from '../utils';\nimport { FilterComparisonOperator } from './constants';\nimport { FiltersParseOptions, FiltersParseOutput, FiltersParseOutputElement } from './type';\nimport { parseFilterValue, transformFilterValue } from './utils';\n\n// --------------------------------------------------\n\nfunction transformFiltersParseOutputElement(element: FiltersParseOutputElement) : FiltersParseOutputElement {\n    if (\n        hasOwnProperty(element, 'path') &&\n        (typeof element.path === 'undefined' || element.path === null)\n    ) {\n        delete element.path;\n    }\n\n    if (element.operator) {\n        return element;\n    }\n\n    if (typeof element.value === 'string') {\n        element = {\n            ...element,\n            ...parseFilterValue(element.value),\n        };\n    } else {\n        element.operator = FilterComparisonOperator.EQUAL;\n    }\n\n    element.value = transformFilterValue(element.value);\n\n    return element;\n}\n\nfunction buildDefaultFiltersParseOutput<T extends ObjectLiteral = ObjectLiteral>(\n    options: FiltersParseOptions<T>,\n    input: Record<string, FiltersParseOutputElement> = {},\n) : FiltersParseOutput {\n    const inputKeys = Object.keys(input || {});\n\n    if (\n        !options.defaultByElement &&\n        inputKeys.length > 0\n    ) {\n        return Object.values(input);\n    }\n\n    if (options.default) {\n        const flatten = flattenNestedObject(options.default);\n        const keys = Object.keys(flatten);\n\n        const output : FiltersParseOutput = [];\n\n        for (let i = 0; i < keys.length; i++) {\n            const fieldDetails = getFieldDetails(keys[i]);\n\n            if (\n                options.defaultByElement &&\n                inputKeys.length > 0\n            ) {\n                const fieldWithAlias = buildFieldWithPath(fieldDetails);\n                if (hasOwnProperty(input, fieldWithAlias)) {\n                    continue;\n                }\n            }\n\n            if (options.defaultByElement || inputKeys.length === 0) {\n                let path : string | undefined;\n                if (fieldDetails.path) {\n                    path = fieldDetails.path;\n                } else if (options.defaultPath) {\n                    path = options.defaultPath;\n                }\n\n                output.push(transformFiltersParseOutputElement({\n                    ...(path ? { path } : {}),\n                    key: fieldDetails.name,\n                    value: flatten[keys[i]],\n                }));\n            }\n        }\n\n        return input ? [...Object.values(input), ...output] : output;\n    }\n\n    return input ? Object.values(input) : [];\n}\n\nexport function parseQueryFilters<T extends ObjectLiteral = ObjectLiteral>(\n    data: unknown,\n    options?: FiltersParseOptions<T>,\n) : FiltersParseOutput {\n    options = options || {};\n    options.mapping = options.mapping || {};\n    options.relations = options.relations || [];\n\n    // If it is an empty array nothing is allowed\n    if (typeof options.allowed !== 'undefined') {\n        options.allowed = flattenParseAllowedOption(options.allowed) as ParseAllowedOption<T>;\n        if (options.allowed.length === 0) {\n            return buildDefaultFiltersParseOutput(options);\n        }\n    }\n\n    /* istanbul ignore next */\n    if (typeof data !== 'object' || data === null) {\n        return buildDefaultFiltersParseOutput(options);\n    }\n\n    const { length } = Object.keys(data);\n    if (length === 0) {\n        return buildDefaultFiltersParseOutput(options);\n    }\n\n    if (\n        (typeof options.allowed === 'undefined' || options.allowed.length === 0) &&\n        options.default\n    ) {\n        const flatten = flattenNestedObject(options.default);\n        options.allowed = Object.keys(flatten) as ParseAllowedOption<T>;\n    }\n\n    const items : Record<string, FiltersParseOutputElement> = {};\n\n    // transform to appreciate data format & validate input\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        /* istanbul ignore next */\n        if (!hasOwnProperty(data, keys[i])) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n\n        const value : unknown = data[keys[i]];\n\n        if (\n            typeof value !== 'string' &&\n            typeof value !== 'number' &&\n            typeof value !== 'boolean' &&\n            typeof value !== 'undefined' &&\n            value !== null &&\n            !Array.isArray(value)\n        ) {\n            continue;\n        }\n\n        keys[i] = applyMapping(keys[i], options.mapping);\n\n        const fieldDetails : FieldDetails = getFieldDetails(keys[i]);\n\n        if (\n            typeof options.allowed === 'undefined' &&\n            !isValidFieldName(fieldDetails.name)\n        ) {\n            continue;\n        }\n\n        if (\n            !isFieldPathAllowedByRelations(fieldDetails, options.relations) &&\n            !isFieldNonRelational(fieldDetails)\n        ) {\n            continue;\n        }\n\n        const fullKey : string = buildFieldWithPath(fieldDetails);\n\n        if (\n            options.allowed &&\n            !isPathCoveredByParseAllowedOption(options.allowed, [keys[i], fullKey])\n        ) {\n            continue;\n        }\n\n        const filter = transformFiltersParseOutputElement({\n            key: fieldDetails.name,\n            value: value as string | boolean | number,\n        });\n\n        if (options.validate) {\n            if (Array.isArray(filter.value)) {\n                const output : (string | number)[] = [];\n                for (let j = 0; j < filter.value.length; j++) {\n                    if (options.validate(filter.key as NestedKeys<T>, filter.value[j])) {\n                        output.push(filter.value[j]);\n                    }\n                }\n\n                filter.value = output as string[] | number[];\n                if (filter.value.length === 0) {\n                    continue;\n                }\n            } else if (!options.validate(filter.key as NestedKeys<T>, filter.value)) {\n                continue;\n            }\n        }\n\n        if (\n            typeof filter.value === 'string' &&\n            filter.value.length === 0\n        ) {\n            continue;\n        }\n\n        if (\n            Array.isArray(filter.value) &&\n            filter.value.length === 0\n        ) {\n            continue;\n        }\n\n        if (fieldDetails.path || options.defaultPath) {\n            filter.path = fieldDetails.path || options.defaultPath;\n        }\n\n        items[fullKey] = filter;\n    }\n\n    return buildDefaultFiltersParseOutput(options, items);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { merge } from 'smob';\nimport { PaginationBuildInput } from './type';\n\nexport function mergeQueryPagination(\n    target?: PaginationBuildInput,\n    source?: PaginationBuildInput,\n) : PaginationBuildInput {\n    return merge({}, target || {}, source || {});\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport { PaginationParseOptions, PaginationParseOutput } from './type';\n\n// --------------------------------------------------\n\nfunction finalizePagination(\n    data: PaginationParseOutput,\n    options: PaginationParseOptions,\n) : PaginationParseOutput {\n    if (typeof options.maxLimit !== 'undefined') {\n        if (\n            typeof data.limit === 'undefined' ||\n            data.limit > options.maxLimit\n        ) {\n            data.limit = options.maxLimit;\n        }\n    }\n\n    if (\n        typeof data.limit !== 'undefined' &&\n        typeof data.offset === 'undefined'\n    ) {\n        data.offset = 0;\n    }\n\n    return data;\n}\n\n/**\n * Transform pagination data to an appreciate data format.\n *\n * @param data\n * @param options\n */\nexport function parseQueryPagination(\n    data: unknown,\n    options?: PaginationParseOptions,\n) : PaginationParseOutput {\n    options = options || {};\n\n    const pagination : PaginationParseOutput = {};\n\n    if (!isObject(data)) {\n        return finalizePagination(pagination, options);\n    }\n\n    let { limit, offset } = data as Record<string, any>;\n\n    if (typeof limit !== 'undefined') {\n        limit = parseInt(limit, 10);\n\n        if (!Number.isNaN(limit) && limit > 0) {\n            pagination.limit = limit;\n        }\n    }\n\n    if (typeof offset !== 'undefined') {\n        offset = parseInt(offset, 10);\n\n        if (!Number.isNaN(offset) && offset >= 0) {\n            pagination.offset = offset;\n        }\n    }\n\n    return finalizePagination(pagination, options);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { mergeArrays } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport { RelationsBuildInput } from './type';\nimport { flattenToKeyPathArray } from '../../utils';\n\nexport function buildQueryRelations<T extends ObjectLiteral = ObjectLiteral>(\n    input?: RelationsBuildInput<T>,\n) : string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    return flattenToKeyPathArray(input);\n}\n\nexport function mergeQueryRelations(\n    target?: string[],\n    source?: string[],\n) : string[] {\n    return mergeArrays(target || [], source || [], true);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function includeParents(\n    data: string[],\n) : string[] {\n    for (let i = 0; i < data.length; i++) {\n        const parts: string[] = data[i].split('.');\n\n        while (parts.length > 0) {\n            parts.pop();\n\n            if (parts.length > 0) {\n                const value = parts.join('.');\n                if (data.indexOf(value) === -1) {\n                    data.unshift(value);\n                }\n            }\n        }\n    }\n\n    return data;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ObjectLiteral } from '../../type';\nimport { applyMapping, hasOwnProperty } from '../../utils';\nimport { isPathCoveredByParseAllowedOption } from '../utils';\n\nimport { RelationsParseOptions, RelationsParseOutput } from './type';\nimport { includeParents, isValidRelationPath } from './utils';\n\n// --------------------------------------------------\n\nexport function parseQueryRelations<T extends ObjectLiteral = ObjectLiteral>(\n    input: unknown,\n    options: RelationsParseOptions<T> = {},\n): RelationsParseOutput {\n    options = options || {};\n\n    // If it is an empty array nothing is allowed\n    if (\n        Array.isArray(options.allowed) &&\n        options.allowed.length === 0\n    ) {\n        return [];\n    }\n\n    options.mapping = options.mapping || {};\n    options.pathMapping = options.pathMapping || {};\n    if (typeof options.includeParents === 'undefined') {\n        options.includeParents = true;\n    }\n\n    let items: string[] = [];\n\n    if (typeof input === 'string') {\n        items = input.split(',');\n    } else if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (typeof input[i] === 'string') {\n                items.push(input[i]);\n            }\n        }\n    }\n\n    if (items.length === 0) {\n        return [];\n    }\n\n    const mappingKeys = Object.keys(options.mapping);\n    if (mappingKeys.length > 0) {\n        for (let i = 0; i < items.length; i++) {\n            items[i] = applyMapping(items[i], options.mapping);\n        }\n    }\n\n    if (options.allowed) {\n        items = items.filter((item) => isPathCoveredByParseAllowedOption(options.allowed as string[], item));\n    } else {\n        items = items.filter((item) => isValidRelationPath(item));\n    }\n\n    if (options.includeParents) {\n        if (Array.isArray(options.includeParents)) {\n            const parentIncludes = items.filter(\n                (item) => item.includes('.') &&\n                    (options.includeParents as string[]).filter((parent) => item.startsWith(parent)).length > 0,\n            );\n            items.unshift(...includeParents(parentIncludes));\n        } else {\n            items = includeParents(items);\n        }\n    }\n\n    items = Array.from(new Set(items));\n\n    return items\n        .map((key) => {\n            const parts = key.split('.');\n\n            let value : string;\n            if (\n                options.pathMapping &&\n                hasOwnProperty(options.pathMapping, key)\n            ) {\n                value = options.pathMapping[key];\n            } else {\n                value = parts.pop() as string;\n            }\n\n            return {\n                key,\n                value,\n            };\n        });\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isValidRelationPath(input: string) : boolean {\n    return /^[a-zA-Z0-9_-]+([.]*[a-zA-Z0-9_-])*$/gu.test(input);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { mergeArrays } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport { SortBuildInput, SortDirection } from './type';\nimport { flattenToKeyPathArray } from '../../utils';\n\nexport function buildQuerySort<T extends ObjectLiteral = ObjectLiteral>(\n    data?: SortBuildInput<T>,\n) {\n    if (typeof data === 'undefined') {\n        return [];\n    }\n\n    if (typeof data === 'string') {\n        return [data];\n    }\n\n    return flattenToKeyPathArray(data, {\n        transformer: ((input, output, path) => {\n            if (\n                typeof input === 'string' &&\n                path &&\n                (\n                    input === SortDirection.ASC ||\n                    input === SortDirection.DESC\n                )\n            ) {\n                if (input === SortDirection.DESC) {\n                    output.push(`-${path}`);\n                } else {\n                    output.push(path);\n                }\n\n                return true;\n            }\n\n            return undefined;\n        }),\n    });\n}\n\nexport function mergeQuerySort(\n    target?: string[],\n    source?: string[],\n) {\n    return mergeArrays(target || [], source || [], true);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { SortDirection } from './type';\n\nexport function parseSortValue(value: string) : {value: string, direction: `${SortDirection}`} {\n    let direction: SortDirection = SortDirection.ASC;\n    if (value.substring(0, 1) === '-') {\n        direction = SortDirection.DESC;\n        value = value.substring(1);\n    }\n\n    return {\n        direction,\n        value,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport { ObjectLiteral } from '../../type';\nimport {\n    applyMapping,\n    buildFieldWithPath, buildKeyPath, flattenNestedObject,\n    getFieldDetails,\n    hasOwnProperty, isFieldNonRelational,\n    isFieldPathAllowedByRelations,\n} from '../../utils';\nimport { isValidFieldName } from '../fields';\nimport { ParseAllowedOption } from '../type';\nimport { flattenParseAllowedOption, isPathCoveredByParseAllowedOption } from '../utils';\n\nimport {\n    SortParseOptions,\n    SortParseOutput,\n    SortParseOutputElement,\n} from './type';\nimport { parseSortValue } from './utils';\n\n// --------------------------------------------------\n\nfunction isMultiDimensionalArray(arr: unknown) : arr is unknown[][] {\n    if (!Array.isArray(arr)) {\n        return false;\n    }\n\n    return arr.length > 0 && Array.isArray(arr[0]);\n}\n\nfunction buildDefaultSortParseOutput<T extends ObjectLiteral = ObjectLiteral>(\n    options: SortParseOptions<T>,\n) : SortParseOutput {\n    if (options.default) {\n        const output : SortParseOutput = [];\n\n        const flatten = flattenNestedObject(options.default);\n        const keys = Object.keys(flatten);\n\n        for (let i = 0; i < keys.length; i++) {\n            const fieldDetails = getFieldDetails(keys[i]);\n\n            let path : string | undefined;\n            if (fieldDetails.path) {\n                path = fieldDetails.path;\n            } else if (options.defaultPath) {\n                path = options.defaultPath;\n            }\n\n            output.push({\n                key: fieldDetails.name,\n                ...(path ? { path } : {}),\n                value: flatten[keys[i]],\n            });\n        }\n\n        return output;\n    }\n\n    return [];\n}\n\n/**\n * Transform sort data to appreciate data format.\n * @param data\n * @param options\n */\nexport function parseQuerySort<T extends ObjectLiteral = ObjectLiteral>(\n    data: unknown,\n    options?: SortParseOptions<T>,\n) : SortParseOutput {\n    options = options || {};\n\n    // If it is an empty array nothing is allowed\n    if (typeof options.allowed !== 'undefined') {\n        const allowed = flattenParseAllowedOption(options.allowed) as ParseAllowedOption<T>;\n        if (allowed.length === 0) {\n            return buildDefaultSortParseOutput(options);\n        }\n    }\n\n    options.mapping = options.mapping || {};\n\n    /* istanbul ignore next */\n    if (\n        typeof data !== 'string' &&\n        !Array.isArray(data) &&\n        !isObject(data)\n    ) {\n        return buildDefaultSortParseOutput(options);\n    }\n\n    if (\n        typeof options.allowed === 'undefined' &&\n        options.default\n    ) {\n        const flatten = flattenNestedObject(options.default);\n        options.allowed = Object.keys(flatten) as ParseAllowedOption<T>;\n    }\n\n    let parts : string[] = [];\n\n    if (typeof data === 'string') {\n        parts = data.split(',');\n    }\n\n    if (Array.isArray(data)) {\n        parts = data.filter((item) => typeof item === 'string');\n    }\n\n    if (\n        typeof data === 'object' &&\n        data !== null\n    ) {\n        const keys = Object.keys(data);\n        for (let i = 0; i < keys.length; i++) {\n            /* istanbul ignore next */\n            if (\n                !hasOwnProperty(data, keys[i]) ||\n                typeof keys[i] !== 'string' ||\n                typeof data[keys[i]] !== 'string'\n            ) continue;\n\n            const fieldPrefix = (data[keys[i]] as string)\n                .toLowerCase() === 'desc' ? '-' : '';\n\n            parts.push(fieldPrefix + keys[i]);\n        }\n    }\n\n    const items : Record<string, SortParseOutputElement> = {};\n\n    let matched = false;\n\n    for (let i = 0; i < parts.length; i++) {\n        const { value, direction } = parseSortValue(parts[i]);\n        parts[i] = value;\n\n        const key: string = applyMapping(parts[i], options.mapping);\n\n        const fieldDetails = getFieldDetails(key);\n\n        if (\n            typeof options.allowed === 'undefined' &&\n            !isValidFieldName(fieldDetails.name)\n        ) {\n            continue;\n        }\n\n        if (\n            !isFieldPathAllowedByRelations(fieldDetails, options.relations) &&\n            !isFieldNonRelational(fieldDetails)\n        ) {\n            continue;\n        }\n\n        const keyWithAlias : string = buildFieldWithPath(fieldDetails);\n\n        if (\n            typeof options.allowed !== 'undefined' &&\n            !isMultiDimensionalArray(options.allowed) &&\n            !isPathCoveredByParseAllowedOption(options.allowed, [key, keyWithAlias])\n        ) {\n            continue;\n        }\n\n        matched = true;\n\n        let path : string | undefined;\n        if (fieldDetails.path) {\n            path = fieldDetails.path;\n        } else if (options.defaultPath) {\n            path = options.defaultPath;\n        }\n\n        items[keyWithAlias] = {\n            key: fieldDetails.name,\n            ...(path ? { path } : {}),\n            value: direction,\n        };\n    }\n\n    if (!matched) {\n        return buildDefaultSortParseOutput(options);\n    }\n\n    if (isMultiDimensionalArray(options.allowed)) {\n        // eslint-disable-next-line no-labels,no-restricted-syntax\n        outerLoop:\n        for (let i = 0; i < options.allowed.length; i++) {\n            const temp : SortParseOutput = [];\n\n            const keyPaths = flattenParseAllowedOption(options.allowed[i] as string[]);\n\n            for (let j = 0; j < keyPaths.length; j++) {\n                let keyWithAlias : string = keyPaths[j];\n                let key : string;\n\n                const parts = keyWithAlias.split('.');\n                if (parts.length > 1) {\n                    key = parts.pop() as string;\n                } else {\n                    key = keyWithAlias;\n\n                    keyWithAlias = buildKeyPath(key, options.defaultPath);\n                }\n\n                if (\n                    hasOwnProperty(items, key) ||\n                    hasOwnProperty(items, keyWithAlias)\n                ) {\n                    const item = hasOwnProperty(items, key) ?\n                        items[key] :\n                        items[keyWithAlias];\n\n                    temp.push(item);\n                } else {\n                    // eslint-disable-next-line no-labels\n                    continue outerLoop;\n                }\n            }\n\n            return temp;\n        }\n\n        // if we get no match, the sort data is invalid.\n        return [];\n    }\n\n    return Object.values(items);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ObjectLiteral } from '../type';\nimport { BuildInput } from './type';\nimport {\n    buildQueryFields,\n    buildQueryFilters,\n    buildQueryRelations,\n    buildQuerySort,\n    mergeQueryFields,\n    mergeQueryFilters,\n    mergeQueryPagination,\n    mergeQueryRelations,\n    mergeQuerySort,\n} from '../parameter';\nimport { Parameter, URLParameter } from '../constants';\nimport {\n    buildURLQueryString,\n} from '../utils';\n\nexport function buildQuery<T extends ObjectLiteral = ObjectLiteral>(\n    input?: BuildInput<T>,\n) : string {\n    if (!input) {\n        return '';\n    }\n\n    const query: { [key in URLParameter]?: unknown } = {};\n\n    if (\n        typeof input[Parameter.FIELDS] !== 'undefined' ||\n        typeof input[URLParameter.FIELDS] !== 'undefined'\n    ) {\n        query[URLParameter.FIELDS] = mergeQueryFields(\n            buildQueryFields(input[Parameter.FIELDS]),\n            buildQueryFields(input[URLParameter.FIELDS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.FILTERS] !== 'undefined' ||\n        typeof input[URLParameter.FILTERS] !== 'undefined'\n    ) {\n        query[URLParameter.FILTERS] = mergeQueryFilters(\n            buildQueryFilters(input[Parameter.FILTERS]),\n            buildQueryFilters(input[URLParameter.FILTERS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.PAGINATION] !== 'undefined' ||\n        typeof input[URLParameter.PAGINATION] !== 'undefined'\n    ) {\n        query[URLParameter.PAGINATION] = mergeQueryPagination(\n            input[Parameter.PAGINATION],\n            input[URLParameter.PAGINATION],\n        );\n    }\n\n    if (\n        typeof input[Parameter.RELATIONS] !== 'undefined' ||\n        typeof input[URLParameter.RELATIONS] !== 'undefined'\n    ) {\n        query[URLParameter.RELATIONS] = mergeQueryRelations(\n            buildQueryRelations(input[Parameter.RELATIONS]),\n            buildQueryRelations(input[URLParameter.RELATIONS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.SORT] !== 'undefined' ||\n        typeof input[URLParameter.SORT] !== 'undefined'\n    ) {\n        query[URLParameter.SORT] = mergeQuerySort(\n            buildQuerySort(input[Parameter.SORT]),\n            buildQuerySort(input[URLParameter.SORT]),\n        );\n    }\n\n    return buildURLQueryString(query);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function buildURLQueryString(data?: any, withQuestionMark = true) {\n    if (typeof data === 'undefined' || data === null) return '';\n\n    // If the data is already a string, return it as-is\n    if (typeof (data) === 'string') return data;\n\n    // Create a query array to hold the key/value pairs\n    const query = [];\n\n    // Loop through the data object\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        if (Object.prototype.hasOwnProperty.call(data, keys[i])) {\n            let value = data[keys[i]];\n\n            if (value && typeof value === 'object' && value.constructor === Array) {\n                value = value.join(',');\n            }\n\n            if (value && typeof value === 'object' && value.constructor === Object) {\n                const valueKeys = Object.keys(value);\n                for (let j = 0; j < valueKeys.length; j++) {\n                    let v: any = value[valueKeys[j]];\n\n                    if (v && typeof v === 'object' && v.constructor === Array) {\n                        v = v.join(',');\n                    }\n\n                    query.push(`${encodeURIComponent(`${keys[i]}[${valueKeys[j]}]`)}=${encodeURIComponent(v)}`);\n                }\n\n                continue;\n            }\n\n            // Encode each key and value, concatenate them into a string, and push them to the array\n            query.push(`${encodeURIComponent(keys[i])}=${encodeURIComponent(value)}`);\n        }\n    }\n\n    // Join each item in the array with a `&` and return the resulting string\n    return (withQuestionMark ? '?' : '') + query.join('&');\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport {\n    RelationsParseOutput, parseQueryFields, parseQueryFilters, parseQueryPagination, parseQueryRelations, parseQuerySort,\n} from '../../parameter';\nimport {\n    Parameter, URLParameter,\n} from '../../constants';\nimport { ObjectLiteral } from '../../type';\nimport { ParseParameterOptions, ParseParameterOutput } from './type';\n\nexport function parseQueryParameter<\n    P extends `${Parameter}` | `${URLParameter}`,\n    T extends ObjectLiteral = ObjectLiteral,\n    >(\n    key: P,\n    data: unknown,\n    options?: ParseParameterOptions<P, T>,\n    relations?: RelationsParseOutput,\n): ParseParameterOutput<P> {\n    switch (key) {\n        case Parameter.FIELDS:\n        case URLParameter.FIELDS:\n            return (parseQueryFields(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.FIELDS>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.FILTERS:\n        case URLParameter.FILTERS:\n            return (parseQueryFilters(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.FILTERS>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.PAGINATION:\n        case URLParameter.PAGINATION:\n            return (parseQueryPagination(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.PAGINATION>,\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.RELATIONS:\n        case URLParameter.RELATIONS:\n            return (parseQueryRelations(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.RELATIONS>,\n                },\n            ) as ParseParameterOutput<P>);\n        default:\n            return (parseQuerySort(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.SORT>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n    }\n}\n\nfunction invalidToEmptyObject<V>(\n    value: V | boolean,\n): NonNullable<V> {\n    return typeof value === 'boolean' ||\n        typeof value === 'undefined' ?\n        {} as NonNullable<V> :\n        value as NonNullable<V>;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\n\nexport function buildQueryParameterOptions<T extends Record<string, any>>(\n    input?: T | boolean,\n) : T {\n    if (isObject(input)) {\n        return input;\n    }\n\n    return {} as T;\n}\n\nexport function isQueryParameterEnabled<T extends Record<string, any>>(\n    input?: T | boolean,\n) : boolean {\n    if (typeof input === 'boolean') {\n        return input;\n    }\n\n    return true;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport {\n    FieldsParseOutput,\n    FiltersParseOutput,\n    PaginationParseOutput,\n    RelationsParseOutput,\n    SortParseOutput,\n} from '../parameter';\nimport { Parameter, URLParameter } from '../constants';\nimport { ObjectLiteral } from '../type';\nimport { buildQueryParameterOptions, isQueryParameterEnabled, parseQueryParameter } from './parameter';\nimport { ParseInput, ParseOptions, ParseOutput } from './type';\n\nexport function parseQuery<T extends ObjectLiteral = ObjectLiteral>(\n    input: ParseInput,\n    options: ParseOptions<T> = {},\n) : ParseOutput {\n    options = options || {};\n\n    const mergeWithGlobalOptions = <T extends {[key: string]: any} & {defaultPath?: string} >(data?: T) : T => {\n        if (typeof data !== 'undefined') {\n            if (options.defaultPath) {\n                data.defaultPath = options.defaultPath;\n            }\n        }\n\n        return data || {} as T;\n    };\n\n    const output : ParseOutput = {};\n    if (options.defaultPath) {\n        output.defaultPath = options.defaultPath;\n    }\n\n    let relations : RelationsParseOutput | undefined;\n\n    const keys : Parameter[] = [\n        // relations must be first parameter\n        Parameter.RELATIONS,\n\n        Parameter.FIELDS,\n        Parameter.FILTERS,\n        Parameter.PAGINATION,\n        Parameter.SORT,\n    ];\n\n    for (let i = 0; i < keys.length; i++) {\n        const key : Parameter = keys[i];\n\n        switch (key) {\n            case Parameter.RELATIONS: {\n                const value = input[Parameter.RELATIONS] || input[URLParameter.RELATIONS];\n                if (value && isQueryParameterEnabled(options[Parameter.RELATIONS])) {\n                    relations = parseQueryParameter(\n                        key,\n                        value,\n                        buildQueryParameterOptions(options[Parameter.RELATIONS]),\n                    );\n\n                    output[Parameter.RELATIONS] = relations;\n                }\n                break;\n            }\n            case Parameter.FIELDS: {\n                const value = input[Parameter.FIELDS] || input[URLParameter.FIELDS];\n                if (value && isQueryParameterEnabled(options[Parameter.FIELDS])) {\n                    output[Parameter.FIELDS] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FIELDS])),\n                        relations,\n                    ) as FieldsParseOutput;\n                }\n                break;\n            }\n            case Parameter.FILTERS: {\n                const value = input[Parameter.FILTERS] || input[URLParameter.FILTERS];\n                if (value && isQueryParameterEnabled(options[Parameter.FILTERS])) {\n                    output[Parameter.FILTERS] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FILTERS])),\n                        relations,\n                    ) as FiltersParseOutput;\n                }\n                break;\n            }\n            case Parameter.PAGINATION: {\n                const value = input[Parameter.PAGINATION] || input[URLParameter.PAGINATION];\n                if (value && isQueryParameterEnabled(options[Parameter.PAGINATION])) {\n                    output[Parameter.PAGINATION] = parseQueryParameter(\n                        key,\n                        value,\n                        buildQueryParameterOptions(options[Parameter.PAGINATION]),\n                        relations,\n                    ) as PaginationParseOutput;\n                }\n                break;\n            }\n            case Parameter.SORT: {\n                const value = input[Parameter.SORT] || input[URLParameter.SORT];\n                if (value && isQueryParameterEnabled(options[Parameter.SORT])) {\n                    output[Parameter.SORT] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.SORT])),\n                        relations,\n                    ) as SortParseOutput;\n                }\n                break;\n            }\n        }\n    }\n\n    return output;\n}\n"],"names":["Parameter","URLParameter","DEFAULT_ID","buildKeyPath","key","prefix","flattenToKeyPathArray","input","options","output","transformer","result","Array","isArray","i","length","j","push","keys","Object","value","data","groupArrayByKeyPath","pathItems","parts","split","name","pop","join","prototype","hasOwnProperty","call","_extends","obj","prop","flattenNestedObject","prefixParts","destinationKey","applyMapping","map","onlyKey","run","shift","found","rest","copy","last","unshift","getFieldDetails","field","path","undefined","isFieldNonRelational","isFieldPathAllowedByRelations","includes","details","some","include","buildFieldWithPath","buildQueryFields","mergeQueryFields","target","source","createMerger","array","arrayDistinct","merge","FieldOperator","FilterComparisonOperator","FilterInputOperatorValue","SortDirection","flattenParseAllowedOption","isPathCoveredByParseAllowedOption","paths","items","indexOf","buildFieldDomainRecords","domainFields","removeFieldInputOperator","firstCharacter","substring","INCLUDE","EXCLUDE","transformFieldsInput","fields","default","included","excluded","operator","character","parseFieldsInput","isValidFieldName","test","parseQueryFields","defaultDomainFields","allowedDomainFields","allowed","isObject","mapping","reverseMapping","record","buildReverseRecord","relations","transformed","filter","from","Set","index","splice","destPath","defaultPath","buildQueryFilters","mergeQueryFilters","transformFilterValue","lower","trim","toLowerCase","num","Number","isNaN","n","matchOperator","position","match","parseFilterValue","IN","negation","NEGATION","NOT_IN","LIKE","NOT_LIKE","LESS_THAN_EQUAL","LESS_THAN","MORE_THAN_EQUAL","GREATER_THAN_EQUAL","MORE_THAN","GREATER_THAN","NOT_EQUAL","EQUAL","transformFiltersParseOutputElement","element","buildDefaultFiltersParseOutput","inputKeys","defaultByElement","values","flatten","fieldDetails","parseQueryFilters","fullKey","validate","mergeQueryPagination","finalizePagination","maxLimit","limit","offset","parseQueryPagination","pagination","parseInt","buildQueryRelations","mergeQueryRelations","mergeArrays","includeParents","parseQueryRelations","pathMapping","item","isValidRelationPath","parentIncludes","parent","startsWith","buildQuerySort","ASC","DESC","mergeQuerySort","parseSortValue","direction","isMultiDimensionalArray","arr","buildDefaultSortParseOutput","parseQuerySort","fieldPrefix","matched","keyWithAlias","outerLoop","temp","keyPaths","buildQuery","query","FIELDS","FILTERS","PAGINATION","RELATIONS","SORT","withQuestionMark","constructor","valueKeys","v","encodeURIComponent","buildURLQueryString","parseQueryParameter","invalidToEmptyObject","buildQueryParameterOptions","isQueryParameterEnabled","parseQuery","mergeWithGlobalOptions"],"mappings":"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"}