'use strict';

var ebec = require('ebec');
var createJITI = require('jiti');
var node_url = require('node:url');
var glob = require('glob');
var path = require('node:path');
var fs = require('node:fs');

function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
function hasStringProperty(obj, prop) {
    return hasOwnProperty(obj, prop) && typeof obj[prop] === 'string';
}

/*
 * Copyright (c) 2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function isObject(item) {
    return !!item && typeof item === 'object' && !Array.isArray(item);
}

function handleException(e) {
    if (e instanceof Error) {
        throw e;
    }
    const error = new Error('Can not process thrown exception.');
    if (isObject(e)) {
        if (hasOwnProperty(e, 'message') && typeof e.message === 'string') {
            error.message = e.message;
        }
        if (hasOwnProperty(e, 'stack') && typeof e.stack === 'string') {
            error.stack = e.stack;
        }
    }
    throw error;
}

/*
 * Copyright (c) 2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function removeFileNameExtension(input, extensions) {
    if (input.includes('.')) {
        const position = input.lastIndexOf('.');
        const extension = input.substring(position, input.length);
        if (typeof extensions === 'undefined' || extensions.indexOf(extension) !== -1) {
            input = input.substring(0, position);
        }
    }
    return input;
}

/*
 * Copyright (c) 2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function toArray(input) {
    return Array.isArray(input) ? input : [
        input
    ];
}

function isFilePath(input) {
    const extension = path.extname(input);
    return extension && extension !== '';
}

/*
 * Copyright (c) 2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ var _options;
function buildLocatorOptions(options) {
    options = options || {};
    options.path = options.path || [];
    options.path = toArray(options.path);
    if (options.path.length === 0) {
        options.path.push(process.cwd());
    }
    (_options = options).ignore ?? (_options.ignore = []);
    return options;
}
function pathToLocatorInfo(input, skipResolve) {
    if (!skipResolve && !path.isAbsolute(input)) {
        input = path.resolve(process.cwd(), input);
    }
    const info = path.parse(input);
    return {
        path: info.dir.split('/').join(path.sep),
        name: info.name,
        extension: info.ext
    };
}
function isLocatorInfo(input) {
    return isObject(input) && typeof input.path === 'string' && typeof input.name === 'string' && typeof input.extension === 'string';
}
function buildFilePath(input) {
    if (typeof input === 'string') {
        return input;
    }
    if (input.extension) {
        return path.join(input.path, input.name) + input.extension;
    }
    return path.join(input.path, input.name);
}
function buildFilePathWithoutExtension(input) {
    let info;
    if (typeof input === 'string') {
        info = pathToLocatorInfo(input);
    } else {
        info = input;
    }
    return path.join(info.path, info.name);
}

async function locateMany(pattern, options) {
    options = buildLocatorOptions(options);
    const patterns = Array.isArray(pattern) ? pattern : [
        pattern
    ];
    const items = [];
    for(let i = 0; i < patterns.length; i++){
        for(let j = 0; j < options.path.length; j++){
            const files = await glob.glob(patterns[i], {
                absolute: true,
                cwd: options.path[j],
                nodir: true,
                ignore: options.ignore
            });
            for(let k = 0; k < files.length; k++){
                items.push(pathToLocatorInfo(files[k], true));
            }
        }
    }
    return items;
}
async function locate(pattern, options) {
    options = buildLocatorOptions(options);
    const patterns = Array.isArray(pattern) ? pattern : [
        pattern
    ];
    for(let i = 0; i < patterns.length; i++){
        for(let j = 0; j < options.path.length; j++){
            const files = await glob.glob(patterns[i], {
                absolute: true,
                cwd: options.path[j],
                nodir: true,
                ignore: options.ignore
            });
            const element = files.shift();
            if (element) {
                return pathToLocatorInfo(element, true);
            }
        }
    }
    return undefined;
}

function locateManySync(pattern, options) {
    options = buildLocatorOptions(options);
    const patterns = Array.isArray(pattern) ? pattern : [
        pattern
    ];
    const items = [];
    for(let i = 0; i < patterns.length; i++){
        for(let j = 0; j < options.path.length; j++){
            const files = glob.globSync(patterns[i], {
                absolute: true,
                cwd: options.path[j],
                nodir: true,
                ignore: options.ignore
            });
            for(let k = 0; k < files.length; k++){
                items.push(pathToLocatorInfo(files[k], true));
            }
        }
    }
    return items;
}
function locateSync(pattern, options) {
    options = buildLocatorOptions(options);
    const patterns = Array.isArray(pattern) ? pattern : [
        pattern
    ];
    for(let i = 0; i < patterns.length; i++){
        for(let j = 0; j < options.path.length; j++){
            const files = glob.globSync(patterns[i], {
                absolute: true,
                cwd: options.path[j],
                nodir: true,
                ignore: options.ignore
            });
            const element = files.shift();
            if (element) {
                return pathToLocatorInfo(element, true);
            }
        }
    }
    return undefined;
}

function isJestRuntimeEnvironment() {
    return process.env && process.env.JEST_WORKER_ID !== undefined;
}
function isTsNodeRuntimeEnvironment() {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return !!process[Symbol.for('ts-node.register.instance')];
}
function getModuleExport(data, filterFn) {
    if (filterFn) {
        const keys = Object.keys(data);
        for(let i = 0; i < keys.length; i++){
            if (filterFn(keys[i], data[keys[i]])) {
                return {
                    key: keys[i],
                    value: data[keys[i]]
                };
            }
        }
        throw new ebec.BaseError('Cannot find specific module export.');
    }
    let value;
    if (hasOwnProperty(data, '__esModule') && // eslint-disable-next-line no-underscore-dangle
    !!data.__esModule && hasOwnProperty(data, 'default')) {
        value = data.default;
    } else {
        value = data;
    }
    if (isObject(value) && hasOwnProperty(value, 'default')) {
        value = value.default;
    }
    return {
        key: 'default',
        value
    };
}

class ModuleLoader {
    async execute(input) {
        let output;
        try {
            output = await this.load(input);
        } catch (e) {
            // jiti + ts-node
            // issue: https://github.com/nuxt/bridge/issues/228
            if (isTsNodeRuntimeEnvironment()) {
                output = this.loadSync(input);
            } else {
                output = this.jiti(input);
            }
        }
        return output;
    }
    executeSync(input) {
        let output;
        try {
            output = this.loadSync(input);
        } catch (e) {
            output = this.jiti(input);
        }
        return output;
    }
    // ---------------------------------------------------------------------------
    async load(data, options) {
        options = options || {};
        const [name, locatorInfo] = this.build(data, options);
        try {
            // segmentation fault
            // issue: https://github.com/nodejs/node/issues/35889
            if (isJestRuntimeEnvironment()) {
                // eslint-disable-next-line global-require,import/no-dynamic-require
                return require(name);
            }
            return await import(name);
        } catch (e) {
            /* istanbul ignore next */ if (isObject(e) && hasStringProperty(e, 'code')) {
                if (locatorInfo) {
                    if (!options.withExtension && (e.code === 'ERR_MODULE_NOT_FOUND' || e.code === 'MODULE_NOT_FOUND')) {
                        return this.load(locatorInfo, {
                            ...options,
                            withExtension: true
                        });
                    }
                    if (!options.withFilePrefix && (e.code === 'ERR_UNSUPPORTED_ESM_URL_SCHEME' || e.code === 'UNSUPPORTED_ESM_URL_SCHEME')) {
                        return this.load(locatorInfo, {
                            ...options,
                            withFilePrefix: true
                        });
                    }
                }
                throw new ebec.BaseError({
                    code: e.code,
                    message: hasStringProperty(e, 'message') ? e.message : undefined,
                    stack: hasStringProperty(e, 'stack') ? e.stack : undefined
                });
            }
            /* istanbul ignore next */ return handleException(e);
        }
    }
    loadSync(data, options) {
        options = options || {};
        const [name, locatorInfo] = this.build(data, options);
        try {
            // eslint-disable-next-line global-require,import/no-dynamic-require
            return require(name);
        } catch (e) {
            /* istanbul ignore next */ if (isObject(e) && hasStringProperty(e, 'code')) {
                if (locatorInfo) {
                    if (!options.withExtension && (e.code === 'ERR_MODULE_NOT_FOUND' || e.code === 'MODULE_NOT_FOUND')) {
                        return this.loadSync(locatorInfo, {
                            ...options,
                            withExtension: true
                        });
                    }
                }
                throw new ebec.BaseError({
                    code: e.code,
                    message: hasStringProperty(e, 'message') ? e.message : undefined,
                    stack: hasStringProperty(e, 'stack') ? e.stack : undefined
                });
            }
            return handleException(e);
        }
    }
    build(data, options) {
        let name;
        let locatorInfo;
        options = options || {};
        if (isLocatorInfo(data) || isFilePath(data)) {
            if (typeof data === 'string') {
                locatorInfo = pathToLocatorInfo(data);
            } else {
                locatorInfo = data;
            }
            if (options.withExtension) {
                name = buildFilePath(locatorInfo);
            } else {
                name = buildFilePathWithoutExtension(locatorInfo);
            }
            if (options.withFilePrefix) {
                name = node_url.pathToFileURL(name).href;
            }
        } else {
            name = data;
        }
        return [
            name,
            locatorInfo
        ];
    }
    constructor(){
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.jiti = createJITI(undefined, {
            extensions: [
                '.js',
                '.mjs',
                '.mts',
                '.cjs',
                '.cts',
                '.ts'
            ]
        });
    }
}

class JSONLoader {
    async execute(input) {
        const filePath = buildFilePath(input);
        try {
            const file = await fs.promises.readFile(filePath);
            return JSON.parse(file.toString('utf-8'));
        } catch (e) {
            return handleException(e);
        }
    }
    executeSync(input) {
        const filePath = buildFilePath(input);
        try {
            const file = fs.readFileSync(filePath);
            return JSON.parse(file.toString('utf-8'));
        } catch (e) {
            return handleException(e);
        }
    }
}

/*
 * Copyright (c) 2023.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ var LoaderId;
(function(LoaderId) {
    LoaderId["MODULE"] = 'module';
    LoaderId["JSON"] = 'json';
})(LoaderId || (LoaderId = {}));

class LoaderManager {
    register(test, loader) {
        if (typeof loader !== 'undefined') {
            this.rules.push({
                test,
                loader
            });
            return;
        }
        this.rules.push(test);
    }
    async execute(input) {
        const id = this.findLoader(input);
        if (!id) {
            const info = pathToLocatorInfo(input);
            throw new Error(`No loader registered for extension: "${info.extension}"`);
        }
        const loader = this.resolve(id);
        return loader.execute(input);
    }
    executeSync(input) {
        const id = this.findLoader(input);
        if (!id) {
            const info = pathToLocatorInfo(input);
            throw new Error(`No loader registered for extension: ${info.extension || 'unknown'}`);
        }
        const loader = this.resolve(id);
        return loader.executeSync(input);
    }
    findLoader(input) {
        if (!isFilePath(input)) {
            return LoaderId.MODULE;
        }
        const info = pathToLocatorInfo(input);
        for(let i = 0; i < this.rules.length; i++){
            const { test  } = this.rules[i];
            if (Array.isArray(test)) {
                if (test.indexOf(info.extension) !== -1) {
                    return this.rules[i].loader;
                }
            } else if (test.test(buildFilePath(info))) {
                return this.rules[i].loader;
            }
        }
        return undefined;
    }
    /**
     * Resolve loader by id.
     *
     * @param id
     */ resolve(id) {
        if (typeof id !== 'string') {
            return id;
        }
        if (Object.prototype.hasOwnProperty.call(this.loaders, id)) {
            return this.loaders[id];
        }
        let loader;
        // built-in
        switch(id){
            case LoaderId.MODULE:
                {
                    loader = new ModuleLoader();
                    break;
                }
            case LoaderId.JSON:
                {
                    loader = new JSONLoader();
                    break;
                }
            /* istanbul ignore next */ default:
                {
                    const pluginPath = this.normalizePath(id);
                    const moduleLoader = this.resolve(LoaderId.MODULE);
                    loader = moduleLoader.executeSync(pluginPath);
                    break;
                }
        }
        if (typeof loader !== 'undefined') {
            this.loaders[id] = loader;
            return loader;
        }
        throw new Error(`The loader ${id} could not be resolved.`);
    }
    /* istanbul ignore next */ normalizePath(input) {
        if (path.isAbsolute(input) || input.startsWith('./')) {
            return input;
        }
        if (input.startsWith('module:')) {
            return input.substring(0, 'module:'.length);
        }
        if (!input.startsWith('@')) {
            return `@locter/${input}`;
        }
        return input;
    }
    constructor(){
        this.loaders = {};
        this.rules = [
            {
                test: [
                    '.js',
                    '.mjs',
                    '.mts',
                    '.cjs',
                    '.cts',
                    '.ts'
                ],
                loader: LoaderId.MODULE
            },
            {
                test: [
                    '.json'
                ],
                loader: LoaderId.JSON
            }
        ];
    }
}

let instance;
function useLoader() {
    if (typeof instance !== 'undefined') {
        return instance;
    }
    instance = new LoaderManager();
    return instance;
}

function registerLoader(test, loader) {
    const manager = useLoader();
    if (typeof loader !== 'undefined') {
        manager.register(test, loader);
        return;
    }
    manager.register(test);
}
async function load(input) {
    const manager = useLoader();
    if (typeof input === 'string') {
        return manager.execute(input);
    }
    return manager.execute(buildFilePath(input));
}
function loadSync(input) {
    const manager = useLoader();
    if (typeof input === 'string') {
        return manager.executeSync(input);
    }
    return manager.executeSync(buildFilePath(input));
}

exports.JSONLoader = JSONLoader;
exports.LoaderManager = LoaderManager;
exports.ModuleLoader = ModuleLoader;
exports.buildFilePath = buildFilePath;
exports.buildFilePathWithoutExtension = buildFilePathWithoutExtension;
exports.buildLocatorOptions = buildLocatorOptions;
exports.getModuleExport = getModuleExport;
exports.handleException = handleException;
exports.hasOwnProperty = hasOwnProperty;
exports.hasStringProperty = hasStringProperty;
exports.isFilePath = isFilePath;
exports.isJestRuntimeEnvironment = isJestRuntimeEnvironment;
exports.isLocatorInfo = isLocatorInfo;
exports.isObject = isObject;
exports.isTsNodeRuntimeEnvironment = isTsNodeRuntimeEnvironment;
exports.load = load;
exports.loadSync = loadSync;
exports.locate = locate;
exports.locateMany = locateMany;
exports.locateManySync = locateManySync;
exports.locateSync = locateSync;
exports.pathToLocatorInfo = pathToLocatorInfo;
exports.registerLoader = registerLoader;
exports.removeFileNameExtension = removeFileNameExtension;
exports.toArray = toArray;
//# sourceMappingURL=index.cjs.map
