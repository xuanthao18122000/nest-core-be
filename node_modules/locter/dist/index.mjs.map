{"version":3,"file":"index.mjs","sources":["../src/utils/has-property.ts","../src/utils/object.ts","../src/utils/error.ts","../src/utils/file-name.ts","../src/utils/to-array.ts","../src/utils/file-path.ts","../src/locator/utils.ts","../src/locator/async.ts","../src/locator/sync.ts","../src/loader/built-in/module/utils.ts","../src/loader/built-in/module/module.ts","../src/loader/built-in/json/module.ts","../src/loader/constants.ts","../src/loader/module.ts","../src/loader/singleton.ts","../src/loader/helpers.ts"],"sourcesContent":["export function hasOwnProperty<X extends Record<string, any>, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function hasStringProperty<X extends Record<string, any>, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, string> {\n    return hasOwnProperty(obj, prop) && typeof obj[prop] === 'string';\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isObject(item: unknown) : item is Record<string, any> {\n    return (\n        !!item &&\n        typeof item === 'object' &&\n        !Array.isArray(item)\n    );\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { hasOwnProperty } from './has-property';\nimport { isObject } from './object';\n\nexport function handleException(e: unknown) : void {\n    if (e instanceof Error) {\n        throw e;\n    }\n\n    const error = new Error('Can not process thrown exception.');\n\n    if (isObject(e)) {\n        if (\n            hasOwnProperty(e, 'message') &&\n            typeof e.message === 'string'\n        ) {\n            error.message = e.message;\n        }\n\n        if (\n            hasOwnProperty(e, 'stack') &&\n            typeof e.stack === 'string'\n        ) {\n            error.stack = e.stack;\n        }\n    }\n\n    throw error;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function removeFileNameExtension(\n    input: string,\n    extensions?: string[],\n) {\n    if (input.includes('.')) {\n        const position = input.lastIndexOf('.');\n        const extension = input.substring(\n            position,\n            input.length,\n        );\n\n        if (\n            typeof extensions === 'undefined' ||\n            extensions.indexOf(extension) !== -1\n        ) {\n            input = input.substring(0, position);\n        }\n    }\n\n    return input;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function toArray(input: string | string[]) : string[] {\n    return Array.isArray(input) ? input : [input];\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\nimport path from 'node:path';\n\nexport function isFilePath(input: string) {\n    const extension = path.extname(input);\n    return extension && extension !== '';\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport path from 'node:path';\nimport { isObject, toArray } from '../utils';\nimport type { LocatorInfo, LocatorOptions } from './type';\n\nexport function buildLocatorOptions(options?: Partial<LocatorOptions>) : LocatorOptions {\n    options = options || {};\n\n    options.path = options.path || [];\n    options.path = toArray(options.path);\n    if (options.path.length === 0) {\n        options.path.push(process.cwd());\n    }\n\n    options.ignore ??= [];\n\n    return options as LocatorOptions;\n}\n\nexport function pathToLocatorInfo(\n    input: string,\n    skipResolve?: boolean,\n) : LocatorInfo {\n    if (\n        !skipResolve &&\n        !path.isAbsolute(input)\n    ) {\n        input = path.resolve(process.cwd(), input);\n    }\n\n    const info = path.parse(input);\n\n    return {\n        path: info.dir.split('/').join(path.sep),\n        name: info.name,\n        extension: info.ext,\n    };\n}\n\nexport function isLocatorInfo(\n    input: unknown,\n) : input is LocatorInfo {\n    return isObject(input) &&\n        typeof input.path === 'string' &&\n        typeof input.name === 'string' &&\n        typeof input.extension === 'string';\n}\n\nexport function buildFilePath(input: LocatorInfo | string) {\n    if (typeof input === 'string') {\n        return input;\n    }\n\n    if (input.extension) {\n        return path.join(input.path, input.name) + input.extension;\n    }\n\n    return path.join(input.path, input.name);\n}\n\nexport function buildFilePathWithoutExtension(input: LocatorInfo | string) {\n    let info: LocatorInfo;\n\n    if (typeof input === 'string') {\n        info = pathToLocatorInfo(input);\n    } else {\n        info = input;\n    }\n\n    return path.join(info.path, info.name);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { glob } from 'glob';\nimport type { LocatorInfo, LocatorOptions } from './type';\nimport { buildLocatorOptions, pathToLocatorInfo } from './utils';\n\nexport async function locateMany(\n    pattern: string | string[],\n    options?: Partial<LocatorOptions>,\n) : Promise<LocatorInfo[]> {\n    options = buildLocatorOptions(options);\n\n    const patterns = Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n\n    const items : LocatorInfo[] = [];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < (options as LocatorOptions).path.length; j++) {\n            const files = await glob(patterns[i] as string, {\n                absolute: true,\n                cwd: (options as LocatorOptions).path[j],\n                nodir: true,\n                ignore: options.ignore,\n            });\n\n            for (let k = 0; k < files.length; k++) {\n                items.push(pathToLocatorInfo(files[k] as string, true));\n            }\n        }\n    }\n\n    return items;\n}\n\nexport async function locate(\n    pattern: string | string[],\n    options?: Partial<LocatorOptions>,\n) : Promise<LocatorInfo | undefined> {\n    options = buildLocatorOptions(options);\n\n    const patterns = Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < (options as LocatorOptions).path.length; j++) {\n            const files = await glob(patterns[i] as string, {\n                absolute: true,\n                cwd: (options as LocatorOptions).path[j],\n                nodir: true,\n                ignore: options.ignore,\n            });\n\n            const element = files.shift();\n            if (element) {\n                return pathToLocatorInfo(element, true);\n            }\n        }\n    }\n\n    return undefined;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { globSync } from 'glob';\nimport type { LocatorInfo, LocatorOptions } from './type';\nimport { buildLocatorOptions, pathToLocatorInfo } from './utils';\n\nexport function locateManySync(\n    pattern: string | string[],\n    options?: Partial<LocatorOptions>,\n) : LocatorInfo[] {\n    options = buildLocatorOptions(options);\n\n    const patterns = Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n\n    const items : LocatorInfo[] = [];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < (options as LocatorOptions).path.length; j++) {\n            const files = globSync(patterns[i] as string, {\n                absolute: true,\n                cwd: (options as LocatorOptions).path[j],\n                nodir: true,\n                ignore: options.ignore,\n            });\n\n            for (let k = 0; k < files.length; k++) {\n                items.push(pathToLocatorInfo(files[k] as string, true));\n            }\n        }\n    }\n\n    return items;\n}\n\nexport function locateSync(\n    pattern: string | string[],\n    options?: Partial<LocatorOptions>,\n) : LocatorInfo | undefined {\n    options = buildLocatorOptions(options);\n\n    const patterns = Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < (options as LocatorOptions).path.length; j++) {\n            const files = globSync(patterns[i] as string, {\n                absolute: true,\n                cwd: (options as LocatorOptions).path[j],\n                nodir: true,\n                ignore: options.ignore,\n            });\n\n            const element = files.shift();\n            if (element) {\n                return pathToLocatorInfo(element, true);\n            }\n        }\n    }\n\n    return undefined;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BaseError } from 'ebec';\nimport { hasOwnProperty, isObject } from '../../../utils';\nimport type { LoaderFilterFn, ModuleExport } from './type';\n\nexport function isJestRuntimeEnvironment() : boolean {\n    return process.env &&\n        process.env.JEST_WORKER_ID !== undefined;\n}\n\nexport function isTsNodeRuntimeEnvironment() : boolean {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return !!process[Symbol.for('ts-node.register.instance')];\n}\n\nexport function getModuleExport(\n    data: Record<string, any>,\n    filterFn?: LoaderFilterFn,\n): ModuleExport {\n    if (filterFn) {\n        const keys = Object.keys(data);\n        for (let i = 0; i < keys.length; i++) {\n            if (filterFn(keys[i] as string, data[keys[i] as string])) {\n                return {\n                    key: keys[i] as string,\n                    value: data[keys[i] as string],\n                };\n            }\n        }\n\n        throw new BaseError('Cannot find specific module export.');\n    }\n\n    let value: any;\n\n    if (\n        hasOwnProperty(data, '__esModule') &&\n        // eslint-disable-next-line no-underscore-dangle\n        !!data.__esModule &&\n        hasOwnProperty(data, 'default')\n    ) {\n        value = data.default;\n    } else {\n        value = data;\n    }\n\n    if (\n        isObject(value) &&\n        hasOwnProperty(value, 'default')\n    ) {\n        value = value.default;\n    }\n\n    return {\n        key: 'default',\n        value,\n    };\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BaseError } from 'ebec';\nimport type { JITI } from 'jiti';\nimport createJITI from 'jiti';\nimport { pathToFileURL } from 'node:url';\nimport type { LocatorInfo } from '../../../locator';\nimport {\n    buildFilePath,\n    buildFilePathWithoutExtension,\n    isLocatorInfo,\n    pathToLocatorInfo,\n} from '../../../locator';\nimport {\n    handleException,\n    hasStringProperty, isFilePath,\n    isObject,\n} from '../../../utils';\nimport type { Loader } from '../../type';\nimport type { ModuleLoadOptions } from './type';\nimport { isJestRuntimeEnvironment, isTsNodeRuntimeEnvironment } from './utils';\n\nexport class ModuleLoader implements Loader {\n    protected jiti : JITI;\n\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.jiti = createJITI(undefined, {\n            extensions: ['.js', '.mjs', '.mts', '.cjs', '.cts', '.ts'],\n        });\n    }\n\n    async execute(input: string) {\n        let output : any;\n\n        try {\n            output = await this.load(input);\n        } catch (e) {\n            // jiti + ts-node\n            // issue: https://github.com/nuxt/bridge/issues/228\n            if (isTsNodeRuntimeEnvironment()) {\n                output = this.loadSync(input);\n            } else {\n                output = this.jiti(input);\n            }\n        }\n\n        return output;\n    }\n\n    executeSync(input: string) {\n        let output : any;\n\n        try {\n            output = this.loadSync(input);\n        } catch (e) {\n            output = this.jiti(input);\n        }\n\n        return output;\n    }\n\n    // ---------------------------------------------------------------------------\n\n    async load(\n        data: LocatorInfo | string,\n        options?: ModuleLoadOptions,\n    ) : Promise<unknown> {\n        options = options || {};\n        const [name, locatorInfo] = this.build(data, options);\n\n        try {\n            // segmentation fault\n            // issue: https://github.com/nodejs/node/issues/35889\n            if (isJestRuntimeEnvironment()) {\n                // eslint-disable-next-line global-require,import/no-dynamic-require\n                return require(name);\n            }\n\n            return await import(name);\n        } catch (e) {\n            /* istanbul ignore next */\n            if (\n                isObject(e) &&\n                hasStringProperty(e, 'code')\n            ) {\n                if (locatorInfo) {\n                    if (\n                        !options.withExtension &&\n                        (\n                            e.code === 'ERR_MODULE_NOT_FOUND' ||\n                            e.code === 'MODULE_NOT_FOUND'\n                        )\n                    ) {\n                        return this.load(locatorInfo, {\n                            ...options,\n                            withExtension: true,\n                        });\n                    }\n\n                    if (\n                        !options.withFilePrefix &&\n                        (\n                            e.code === 'ERR_UNSUPPORTED_ESM_URL_SCHEME' ||\n                            e.code === 'UNSUPPORTED_ESM_URL_SCHEME'\n                        )\n                    ) {\n                        return this.load(locatorInfo, {\n                            ...options,\n                            withFilePrefix: true,\n                        });\n                    }\n                }\n\n                throw new BaseError({\n                    code: e.code,\n                    message: hasStringProperty(e, 'message') ? e.message : undefined,\n                    stack: hasStringProperty(e, 'stack') ? e.stack : undefined,\n                });\n            }\n\n            /* istanbul ignore next */\n            return handleException(e);\n        }\n    }\n\n    loadSync(\n        data: LocatorInfo | string,\n        options?: ModuleLoadOptions,\n    ) : unknown {\n        options = options || {};\n        const [name, locatorInfo] = this.build(data, options);\n\n        try {\n            // eslint-disable-next-line global-require,import/no-dynamic-require\n            return require(name);\n        } catch (e) {\n            /* istanbul ignore next */\n            if (\n                isObject(e) &&\n                hasStringProperty(e, 'code')\n            ) {\n                if (locatorInfo) {\n                    if (\n                        !options.withExtension &&\n                        (\n                            e.code === 'ERR_MODULE_NOT_FOUND' ||\n                            e.code === 'MODULE_NOT_FOUND'\n                        )\n                    ) {\n                        return this.loadSync(locatorInfo, {\n                            ...options,\n                            withExtension: true,\n                        });\n                    }\n                }\n\n                throw new BaseError({\n                    code: e.code,\n                    message: hasStringProperty(e, 'message') ? e.message : undefined,\n                    stack: hasStringProperty(e, 'stack') ? e.stack : undefined,\n                });\n            }\n\n            return handleException(e);\n        }\n    }\n\n    private build(\n        data: LocatorInfo | string,\n        options: ModuleLoadOptions,\n    ) : [string, LocatorInfo | undefined] {\n        let name : string;\n        let locatorInfo : LocatorInfo | undefined;\n\n        options = options || {};\n\n        if (isLocatorInfo(data) || isFilePath(data)) {\n            if (typeof data === 'string') {\n                locatorInfo = pathToLocatorInfo(data);\n            } else {\n                locatorInfo = data;\n            }\n\n            if (options.withExtension) {\n                name = buildFilePath(locatorInfo);\n            } else {\n                name = buildFilePathWithoutExtension(locatorInfo);\n            }\n\n            if (options.withFilePrefix) {\n                name = pathToFileURL(name).href;\n            }\n        } else {\n            name = data;\n        }\n\n        return [name, locatorInfo];\n    }\n}\n","/*\n * Copyright (c) 2022-2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport fs from 'node:fs';\nimport { buildFilePath } from '../../../locator';\nimport { handleException } from '../../../utils';\nimport type { Loader } from '../../type';\n\nexport class JSONLoader implements Loader {\n    async execute(input: string) {\n        const filePath = buildFilePath(input);\n\n        try {\n            const file = await fs.promises.readFile(filePath);\n            return JSON.parse(file.toString('utf-8'));\n        } catch (e) {\n            return handleException(e);\n        }\n    }\n\n    executeSync(input: string) {\n        const filePath = buildFilePath(input);\n\n        try {\n            const file = fs.readFileSync(filePath);\n            return JSON.parse(file.toString('utf-8'));\n        } catch (e) {\n            return handleException(e);\n        }\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum LoaderId {\n    MODULE = 'module',\n    JSON = 'json',\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport path from 'node:path';\nimport { buildFilePath, pathToLocatorInfo } from '../locator';\nimport { isFilePath } from '../utils';\nimport { JSONLoader, ModuleLoader } from './built-in';\nimport { LoaderId } from './constants';\nimport type { Loader, Rule } from './type';\n\nexport class LoaderManager implements Loader {\n    protected loaders : Record<string, Loader>;\n\n    protected rules : Rule[];\n\n    constructor() {\n        this.loaders = {};\n        this.rules = [\n            {\n                test: ['.js', '.mjs', '.mts', '.cjs', '.cts', '.ts'],\n                loader: LoaderId.MODULE,\n            },\n            {\n                test: ['.json'], loader: LoaderId.JSON,\n            },\n        ];\n    }\n\n    register(rule: Rule) : void;\n\n    register(test: string[] | RegExp, loader: Loader) : void;\n\n    register(test: any, loader?: Loader) : void {\n        if (typeof loader !== 'undefined') {\n            this.rules.push({ test, loader });\n            return;\n        }\n\n        this.rules.push(test);\n    }\n\n    async execute(input: string) : Promise<any> {\n        const id = this.findLoader(input);\n        if (!id) {\n            const info = pathToLocatorInfo(input);\n            throw new Error(`No loader registered for extension: \"${info.extension}\"`);\n        }\n\n        const loader = this.resolve(id);\n        return loader.execute(input);\n    }\n\n    executeSync(input: string) : any {\n        const id = this.findLoader(input);\n        if (!id) {\n            const info = pathToLocatorInfo(input);\n            throw new Error(`No loader registered for extension: ${info.extension || 'unknown'}`);\n        }\n\n        const loader = this.resolve(id);\n        return loader.executeSync(input);\n    }\n\n    findLoader(input: string) : Loader | string | undefined {\n        if (!isFilePath(input)) {\n            return LoaderId.MODULE;\n        }\n\n        const info = pathToLocatorInfo(input);\n        for (let i = 0; i < this.rules.length; i++) {\n            const { test } = this.rules[i] as Rule;\n            if (Array.isArray(test)) {\n                if (test.indexOf(info.extension) !== -1) {\n                    return this.rules[i].loader;\n                }\n            } else if (test.test(buildFilePath(info))) {\n                return this.rules[i].loader;\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Resolve loader by id.\n     *\n     * @param id\n     */\n    resolve(id: string | Loader) : Loader {\n        if (typeof id !== 'string') {\n            return id;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(this.loaders, id)) {\n            return this.loaders[id] as Loader;\n        }\n\n        let loader : Loader | undefined;\n\n        // built-in\n        switch (id) {\n            case LoaderId.MODULE: {\n                loader = new ModuleLoader();\n                break;\n            }\n            case LoaderId.JSON: {\n                loader = new JSONLoader();\n                break;\n            }\n            /* istanbul ignore next */\n            default: {\n                const pluginPath = this.normalizePath(id);\n                const moduleLoader = this.resolve(LoaderId.MODULE);\n                loader = moduleLoader.executeSync(pluginPath);\n\n                break;\n            }\n        }\n\n        if (typeof loader !== 'undefined') {\n            this.loaders[id] = loader;\n\n            return loader;\n        }\n\n        throw new Error(`The loader ${id} could not be resolved.`);\n    }\n\n    /* istanbul ignore next */\n    normalizePath(input: string) {\n        if (path.isAbsolute(input) || input.startsWith('./')) {\n            return input;\n        }\n\n        if (input.startsWith('module:')) {\n            return input.substring(0, 'module:'.length);\n        }\n\n        if (!input.startsWith('@')) {\n            return `@locter/${input}`;\n        }\n\n        return input;\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { LoaderManager } from './module';\n\nlet instance : LoaderManager;\nexport function useLoader() {\n    if (typeof instance !== 'undefined') {\n        return instance;\n    }\n\n    instance = new LoaderManager();\n\n    return instance;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { buildFilePath } from '../locator';\nimport type { LocatorInfo } from '../locator';\nimport { useLoader } from './singleton';\nimport type { Loader, Rule } from './type';\n\nexport function registerLoader(rule: Rule) : void;\nexport function registerLoader(test: string[] | RegExp, loader: Loader) : void;\nexport function registerLoader(test: any, loader?: Loader) : void {\n    const manager = useLoader();\n    if (typeof loader !== 'undefined') {\n        manager.register(test, loader);\n\n        return;\n    }\n\n    manager.register(test);\n}\n\nexport async function load(input: LocatorInfo | string) : Promise<any> {\n    const manager = useLoader();\n    if (typeof input === 'string') {\n        return manager.execute(input);\n    }\n\n    return manager.execute(buildFilePath(input));\n}\n\nexport function loadSync(input: LocatorInfo | string) : any {\n    const manager = useLoader();\n    if (typeof input === 'string') {\n        return manager.executeSync(input);\n    }\n\n    return manager.executeSync(buildFilePath(input));\n}\n"],"names":["input","options","name","extension","info","pattern","absolute","cwd","nodir","ignore","items","value","output","executeSync","withExtension","withFilePrefix","code","message","stack","locatorInfo","LoaderId","test","loader","findLoader","instance","manager"],"mappings":";;;;;;;;;;;;;;AAAO;AACH;AACJ;AAEO;AACH;AACJ;;ACNA;;;;;AAKC;;AAQD;;ACHO;AACH;AACI;;;AAKJ;AACI;;;AAOA;;;;AAQJ;AACJ;;AClCA;;;;;AAKC;;;AAQO;;;;;;AAcR;;AC3BA;;;;;AAKC;AAGG;AAAuCA;AAAM;AACjD;;ACDO;;AAEH;AACJ;;ACXA;;;;;;AAWO;AACHC;AAEAA;AACAA;AACA;AACIA;;AAGJA;;AAGJ;AAEO;AAIH;AAIID;;;;;AAOAE;AACAC;AACJ;AACJ;AAEO;AAGH;AAIJ;AAEO;;;;;;;AASH;AACJ;AAEO;;;AAICC;;;;AAKJ;AACJ;;ACjEO;AAIHH;AAEA;AAEKI;AAAQ;AAEb;AAEA;;AAEQ;AACIC;AACAC;AACAC;AACAC;AACJ;AAEA;AACIC;AACJ;AACJ;AACJ;;AAGJ;AAEO;AAIHT;AAEA;AAEKI;AAAQ;AAEb;;AAEQ;AACIC;AACAC;AACAC;AACAC;AACJ;;AAGA;;;AAGJ;AACJ;;AAGJ;;ACzDO;AAIHR;AAEA;AAEKI;AAAQ;AAEb;AAEA;;AAEQ;AACIC;AACAC;AACAC;AACAC;AACJ;AAEA;AACIC;AACJ;AACJ;AACJ;;AAGJ;AAEO;AAIHT;AAEA;AAEKI;AAAQ;AAEb;;AAEQ;AACIC;AACAC;AACAC;AACAC;AACJ;;AAGA;;;AAGJ;AACJ;;AAGJ;;ACzDO;AACH;AAEJ;AAEO;;;AAGH;AACJ;AAEO;AAIH;;AAEI;;;;AAIYE;AACJ;;AAER;;;;;AAUA;AAGAA;;;;AAKJ;AAIIA;;;;AAKAA;AACJ;AACJ;;ACrCO;;;;AAeKC;AACJ;;;AAGI;;;;;AAKJ;;AAGJ;AAEAC;;;;AAKI;;AAEA;;AAGJ;;AAIA;AAIIZ;;;;;AAMI;;AAEI;;;AAIR;AACI;AAKI;AACI;AAOI;AACI;AACAa;AACJ;;AAGJ;AAOI;AACI;AACAC;AACJ;;;AAIR;AACIC;AACAC;AACAC;;;;AAMZ;AACJ;;AAMIjB;;;;AAKI;AACJ;AACI;AAKI;AACI;AAOI;AACI;AACAa;AACJ;;;AAIR;AACIE;AACAC;AACAC;;;AAIR;AACJ;AACJ;;;;AASIjB;;;AAIQkB;;;;;AAMAjB;;AAEAA;;;;;;;;;AAUAA;AAAMiB;AAAY;AAC9B;;;;AA3KI;;AACiB;AAAO;AAAQ;AAAQ;AAAQ;AAAQ;AAAM;AAC9D;AACJ;AAyKJ;;ACjMO;;AAEC;;AAGI;AACA;AACJ;AACI;AACJ;AACJ;AAEAN;AACI;;;AAII;AACJ;AACI;AACJ;AACJ;AACJ;;AClCA;;;;;;;AAOYO;AAAAA;;;ACOL;;;AAwBK;AAAkBC;AAAMC;AAAO;AAC/B;;AAGJ;AACJ;;AAGI;AACA;AACI;;;AAIJ;;AAEJ;AAEAT;AACI;AACA;AACI;;;AAIJ;;AAEJ;AAEAU;;AAEQ;;AAGJ;;;;AAIQ;AACI;;AAER;AACI;;AAER;;AAGJ;AAEA;;;;;;;;;AAWQ;;;;;AAOA;AAAsB;AAClBD;;AAEJ;AACA;AAAoB;AAChBA;;AAEJ;AACA;AACS;AACL;AACA;;;AAIJ;AACJ;;AAGI;;;;AAMR;;AAII;;;;AAKI;;AAGJ;AACI;;;AAIR;;;;AA7HQ;;AACW;AAAO;AAAQ;AAAQ;AAAQ;AAAQ;AAAM;AACpDA;AACJ;AACA;;AACW;AAAQ;AAAEA;AACrB;AACH;AACL;AAsHJ;;AC3IA;AACO;;;;AAKHE;;AAGJ;;ACJO;AACH;;;AAII;;AAGJC;AACJ;AAEO;AACH;;;;;AAMJ;AAEO;AACH;;;;;AAMJ;;"}