"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSeeders = exports.runSeeder = void 0;
const locter_1 = require("locter");
const utils_1 = require("../utils");
const utils_2 = require("./utils");
const data_source_1 = require("../data-source");
const factory_1 = require("./factory");
async function prepareSeeder(options) {
    options = options ?? {};
    options = (0, utils_2.setDefaultSeederOptions)(options);
    await (0, data_source_1.modifyDataSourceOptionsForRuntimeEnvironment)(options, {
        keys: ['seeds', 'factories'],
    });
    if (options.factories) {
        let factoryFiles = [];
        const factoryConfigs = [];
        for (let i = 0; i < options.factories.length; i++) {
            const value = options.factories[i];
            if (typeof value === 'string') {
                factoryFiles.push(value);
            }
            else {
                factoryConfigs.push(value);
            }
        }
        if (factoryFiles.length > 0) {
            factoryFiles = await (0, utils_2.resolveFilePatterns)(factoryFiles);
            factoryFiles = (0, utils_2.resolveFilePaths)(factoryFiles);
            for (let i = 0; i < factoryFiles.length; i++) {
                await (0, locter_1.load)(factoryFiles[i]);
            }
        }
        if (factoryConfigs.length > 0) {
            const factoryManager = (0, factory_1.useSeederFactoryManager)();
            for (let i = 0; i < factoryConfigs.length; i++) {
                factoryManager.set(factoryConfigs[i].entity, factoryConfigs[i].factoryFn);
            }
        }
    }
    const items = [];
    if (options.seeds) {
        let seedFiles = [];
        const seedConstructors = [];
        for (let i = 0; i < options.seeds.length; i++) {
            const value = options.seeds[i];
            if (typeof value === 'string') {
                seedFiles.push(value);
            }
            else {
                seedConstructors.push(value);
            }
        }
        if (seedFiles.length > 0) {
            seedFiles = await (0, utils_2.resolveFilePatterns)(seedFiles);
            seedFiles = (0, utils_2.resolveFilePaths)(seedFiles);
            for (let i = 0; i < seedFiles.length; i++) {
                let fileExport = await (0, locter_1.load)(seedFiles[i]);
                if ((0, utils_1.hasOwnProperty)(fileExport, 'default')) {
                    fileExport = fileExport.default;
                }
                if (fileExport) {
                    const item = fileExport;
                    if (!options.seedName || options.seedName === item.name) {
                        items.push(item);
                    }
                }
            }
        }
        if (seedConstructors.length > 0) {
            for (let i = 0; i < seedConstructors.length; i++) {
                if (!options.seedName || options.seedName === seedConstructors[i].name) {
                    items.push(seedConstructors[i]);
                }
            }
        }
    }
    return items;
}
async function runSeeder(dataSource, seeder, options) {
    if ((0, utils_1.hasOwnProperty)(seeder, 'default')) {
        seeder = seeder.default;
    }
    options = options || {};
    options.seeds = [seeder];
    options.factoriesLoad = options.factoriesLoad ?? true;
    if (options.factoriesLoad &&
        !options.factories) {
        const { factories: dataSourceFactories } = dataSource.options;
        if (typeof dataSourceFactories !== 'undefined') {
            options.factories = dataSourceFactories;
        }
    }
    await prepareSeeder(options);
    (0, data_source_1.setDataSource)(dataSource);
    // eslint-disable-next-line new-cap
    const clazz = new seeder();
    const factoryManager = (0, factory_1.useSeederFactoryManager)();
    return clazz.run(dataSource, factoryManager);
}
exports.runSeeder = runSeeder;
async function runSeeders(dataSource, options) {
    options = options || {};
    const { seeds, factories } = dataSource.options;
    if (typeof options.seeds === 'undefined' &&
        typeof seeds !== 'undefined') {
        options.seeds = seeds;
    }
    if (typeof options.factories === 'undefined' &&
        typeof factories !== 'undefined') {
        options.factories = factories;
    }
    const items = await prepareSeeder(options);
    const promises = [];
    const results = [];
    for (let i = 0; i < items.length; i++) {
        const promise = runSeeder(dataSource, items[i], {
            factoriesLoad: false,
        });
        if (options.parallelExecution) {
            promises.push(promise);
        }
        else {
            await promise;
        }
    }
    if (promises.length > 0) {
        return Promise.all(promises);
    }
    return results;
}
exports.runSeeders = runSeeders;
