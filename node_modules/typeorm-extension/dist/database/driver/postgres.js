"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dropPostgresDatabase = exports.createPostgresDatabase = exports.executeSimplePostgresQuery = exports.createSimplePostgresConnection = void 0;
const locter_1 = require("locter");
const errors_1 = require("../../errors");
const utils_1 = require("../../utils");
const utils_2 = require("./utils");
const utils_3 = require("../utils");
async function createSimplePostgresConnection(driver, options, operationContext) {
    /**
     * pg library
     */
    const { Client } = driver.postgres;
    const data = {
        host: options.host,
        port: options.port,
        user: options.user,
        password: options.password,
        ssl: options.ssl,
        ...(options.extra ? options.extra : {}),
    };
    if (typeof operationContext.initialDatabase === 'string') {
        data.database = operationContext.initialDatabase;
    }
    const client = new Client(data);
    await client.connect();
    return client;
}
exports.createSimplePostgresConnection = createSimplePostgresConnection;
async function executeSimplePostgresQuery(connection, query, endConnection = true) {
    return new Promise(((resolve, reject) => {
        connection.query(query, (queryErr, queryResult) => {
            if (endConnection) {
                connection.end();
            }
            if (queryErr) {
                reject(queryErr);
            }
            resolve(queryResult);
        });
    }));
}
exports.executeSimplePostgresQuery = executeSimplePostgresQuery;
async function createPostgresDatabase(context) {
    context = await (0, utils_3.buildDatabaseCreateContext)(context);
    if (!context.options) {
        throw errors_1.OptionsError.undeterminable();
    }
    const options = (0, utils_2.buildDriverOptions)(context.options);
    const driver = (0, utils_2.createDriver)(context.options);
    const connection = await createSimplePostgresConnection(driver, options, context);
    if (context.ifNotExist) {
        const existQuery = `SELECT * FROM pg_database WHERE lower(datname) = lower('${options.database}');`;
        const existResult = await executeSimplePostgresQuery(connection, existQuery, false);
        if ((0, locter_1.isObject)(existResult) &&
            (0, utils_1.hasOwnProperty)(existResult, 'rows') &&
            Array.isArray(existResult.rows) &&
            existResult.rows.length > 0) {
            await connection.end();
            return Promise.resolve();
        }
    }
    /**
     * @link https://github.com/typeorm/typeorm/blob/master/src/driver/postgres/PostgresQueryRunner.ts#L326
     */
    let query = `CREATE DATABASE "${options.database}"`;
    if (typeof options.characterSet === 'string') {
        query += ` WITH ENCODING '${options.characterSet}'`;
    }
    const result = await executeSimplePostgresQuery(connection, query);
    if (context.synchronize) {
        await (0, utils_3.setupDatabaseSchema)(context.options);
    }
    return result;
}
exports.createPostgresDatabase = createPostgresDatabase;
async function dropPostgresDatabase(context) {
    context = await (0, utils_3.buildDatabaseDropContext)(context);
    if (!context.options) {
        throw errors_1.OptionsError.undeterminable();
    }
    const options = (0, utils_2.buildDriverOptions)(context.options);
    const driver = (0, utils_2.createDriver)(context.options);
    const connection = await createSimplePostgresConnection(driver, options, context);
    /**
     * @link https://github.com/typeorm/typeorm/blob/master/src/driver/postgres/PostgresQueryRunner.ts#L343
     */
    const query = context.ifExist ?
        `DROP DATABASE IF EXISTS "${options.database}"` :
        `DROP DATABASE "${options.database}"`;
    return executeSimplePostgresQuery(connection, query);
}
exports.dropPostgresDatabase = dropPostgresDatabase;
