"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkDatabase = void 0;
const typeorm_1 = require("typeorm");
const data_source_1 = require("../data-source");
const utils_1 = require("../utils");
/**
 * Check database setup progress.
 *
 * @param context
 */
async function checkDatabase(context) {
    context = context || {};
    context.dataSourceCleanup = context.dataSourceCleanup ?? true;
    const result = {
        exists: true,
        schema: false,
        migrationsPending: [],
    };
    let { dataSource } = context;
    if (typeof dataSource === 'undefined' &&
        (0, data_source_1.hasDataSource)(context.alias)) {
        // todo: data-source might get initialized here
        dataSource = await (0, data_source_1.useDataSource)(context.alias);
    }
    const dataSourceExisted = !!dataSource;
    if (typeof dataSource === 'undefined') {
        if (context.options) {
            dataSource = new typeorm_1.DataSource({
                ...context.options,
                synchronize: false,
            });
        }
        else {
            const options = await (0, data_source_1.useDataSourceOptions)(context.alias);
            dataSource = new typeorm_1.DataSource({
                ...options,
                synchronize: false,
            });
        }
    }
    try {
        if (!dataSource.isInitialized) {
            await dataSource.initialize();
        }
    }
    catch (e) {
        result.exists = false;
        return result;
    }
    const queryRunner = dataSource.createQueryRunner();
    if (dataSource.migrations &&
        dataSource.migrations.length > 0) {
        const migrationExecutor = new typeorm_1.MigrationExecutor(dataSource, queryRunner);
        result.migrationsPending = await migrationExecutor.getPendingMigrations();
        if (result.migrationsPending.length === 0) {
            result.schema = true;
        }
    }
    else {
        let schema;
        if ((0, utils_1.hasStringProperty)(dataSource.driver.options, 'schema')) {
            schema = dataSource.driver.options.schema;
        }
        const migrationsTableName = dataSource.driver.buildTableName(dataSource.options.migrationsTableName || 'migrations', schema, dataSource.driver.database);
        const migrationsTableExists = await queryRunner.hasTable(migrationsTableName);
        if (migrationsTableExists) {
            result.schema = dataSource.entityMetadatas.length === 0;
        }
        else {
            const tableNames = dataSource.entityMetadatas.map((entityMetadata) => entityMetadata.tablePath);
            const tables = await queryRunner.getTables(tableNames);
            result.schema = tables.length === dataSource.entityMetadatas.length;
        }
    }
    await queryRunner.release();
    if (!dataSourceExisted) {
        if (context.dataSourceCleanup) {
            await dataSource.destroy();
            if (!context.dataSource) {
                (0, data_source_1.unsetDataSource)(context.alias);
            }
        }
        else {
            (0, data_source_1.setDataSource)(dataSource, context.alias);
        }
    }
    return result;
}
exports.checkDatabase = checkDatabase;
