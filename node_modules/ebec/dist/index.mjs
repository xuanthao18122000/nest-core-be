import { merge } from 'smob';

/*
 * Copyright (c) 2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

/*
 * Copyright (c) 2021-2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
/**
 * Deep merge two objects.
 * @param target
 * @param sources
 */ function mergeOptions(target, ...sources) {
    return merge(target, ...sources);
}
function buildOptions(data, options) {
    if (typeof data === 'undefined') {
        data = {};
    }
    if (typeof options === 'undefined') {
        options = {};
    }
    if (!(data instanceof Error) && typeof data !== 'string') {
        options = mergeOptions({}, data, _extends({}, options));
    }
    if (!options.previous && data instanceof Error) {
        options.previous = data;
    }
    return options;
}

/*
 * Copyright (c) 2022-2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function buildMessage(data, options) {
    if (typeof data === 'undefined') {
        data = {};
    }
    if (typeof options === 'undefined') {
        options = {};
    }
    let message;
    if (typeof data === 'string') {
        message = data;
    }
    if (!message && options.message) {
        message = options.message;
    }
    if (!message && !options.decorateMessage) {
        if (data instanceof Error) {
            /* istanbul ignore next */ message = data.message;
        } else if (options.previous instanceof Error) {
            message = options.previous.message;
        }
    }
    return message;
}

class BaseError extends Error {
    //--------------------------------------------------------------------
    getOptions() {
        return this.options;
    }
    getOption(key) {
        return this.options[key];
    }
    //--------------------------------------------------------------------
    setOptions(options) {
        if (typeof options === 'undefined') {
            options = {};
        }
        const keys = Object.keys(options);
        for(let i = 0; i < keys.length; i++){
            this.setOption(keys[i], options[keys[i]]);
        }
    }
    setOption(key, value) {
        Object.assign(this.options, {
            [key]: value
        });
    }
    unsetOption(key) {
        if (hasOwnProperty(this.options, key)) {
            delete this.options[key];
        }
    }
    //--------------------------------------------------------------------
    constructor(data, options){
        options = buildOptions(data, options);
        const message = buildMessage(data, options);
        super(message);
        if (this.name === undefined || this.name === 'Error') {
            Object.defineProperty(this, 'name', {
                configurable: true,
                enumerable: false,
                value: this.constructor.name,
                writable: true
            });
        }
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
        /* istanbul ignore next */ if (typeof this.stack === 'undefined' || this.stack === '') {
            this.stack = new Error(message).stack;
        }
        this.options = {};
        this.setOptions(options);
    }
}

function isObject(item) {
    return !!item && typeof item === 'object' && !Array.isArray(item);
}
function isFunction(item) {
    return typeof item === 'function';
}
function extendsBaseError(error) {
    if (error instanceof BaseError) {
        return true;
    }
    return !!(isObject(error) && hasOwnProperty(error, 'options') && isObject(error.options) && isFunction(error.getOption) && isFunction(error.getOptions));
}

export { BaseError, buildMessage, buildOptions, extendsBaseError, hasOwnProperty, mergeOptions };
//# sourceMappingURL=index.mjs.map
